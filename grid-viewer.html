<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grid Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #0a0a0a;
        color: #fff;
        overflow-x: hidden;
        user-select: none;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        padding: 0.5rem 1rem;
        z-index: 1600;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        font-size: 0.9rem;
        opacity: 0.8;
      }

      .controls select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .controls select:focus {
        outline: none;
        border-color: #ff6b6b;
      }

      #zoom-slider {
        vertical-align: middle;
      }

      .shortcuts-container {
        position: relative;
      }

      .shortcuts-toggle {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s;
      }

      .shortcuts-toggle:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .shortcuts-list {
        display: none;
        position: absolute;
        top: calc(100% + 0.5rem);
        right: 0;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 1rem;
        min-width: 250px;
        z-index: 2000;
        flex-direction: column;
        gap: 0.75rem;
      }

      .shortcuts-list.visible {
        display: flex;
      }

      .shortcuts-list span {
        white-space: nowrap;
        opacity: 0.9;
      }

      .drop-zone {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.95);
        z-index: 1500;
        transition: opacity 0.3s ease;
      }

      .drop-zone.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .drop-zone.drag-over {
        background: rgba(255, 107, 107, 0.1);
        border: 2px dashed #ff6b6b;
      }

      .drop-zone h2 {
        font-size: 2rem;
        margin-bottom: 1rem;
        color: #fff;
      }

      .drop-zone p {
        font-size: 1.1rem;
        color: #ccc;
        text-align: center;
        max-width: 500px;
      }

      :root {
        --item-width: 18vw;
        --gap: 8px;
      }
      .masonry-grid {
        margin-top: 60px;
        position: relative;
      }
      .media-item {
        position: absolute;
        border: none;
        border-radius: 0;
        overflow: hidden;
        cursor: pointer;
        background: #1a1a1a;
        transition:
          box-shadow 0.2s,
          top 0.3s ease,
          left 0.3s ease,
          width 0.3s ease;
      }
      .media-item.selected {
        outline: 3px solid #ff6b6b;
        z-index: 10;
      }
      .media-item img,
      .media-item video {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }
      .media-item video {
        background: #000;
      }
      .media-placeholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
      }
      .media-item.loaded .media-placeholder {
        display: none;
        opacity: 0;
        pointer-events: none;
      }
      .media-item.virtualized {
        background: #1a1a1a;
      }
      .media-item.virtualized .media-placeholder {
        background: #1a1a1a;
        color: #333;
      }
      .video-time-overlay {
        position: absolute;
        bottom: 6px;
        right: 6px;
        background: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-family: monospace;
        pointer-events: none;
        z-index: 5;
      }
      .fullscreen-overlay {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 2000;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .fullscreen-overlay.active {
        opacity: 1;
        pointer-events: all;
      }
      .fullscreen-content {
        max-width: 100vw;
        max-height: 100vh;
        position: relative;
      }
      .fullscreen-content img,
      .fullscreen-content video {
        max-width: 100vw;
        max-height: 100vh;
        object-fit: contain;
      }
      .scroll-indicator {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.9rem;
        z-index: 1000;
      }
      .file-info-overlay {
        position: fixed;
        bottom: 2rem;
        left: 2rem;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        font-size: 0.9rem;
        z-index: 2100;
        max-width: 400px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        user-select: text;
      }
      .file-info-overlay.visible {
        opacity: 1;
        pointer-events: all;
      }
      .file-info-overlay .info-line {
        margin: 0.25rem 0;
        word-break: break-all;
      }
      .file-info-overlay .info-label {
        opacity: 0.7;
        margin-right: 0.5rem;
      }
      .file-info-overlay a {
        color: #ff6b6b;
        text-decoration: none;
        transition: opacity 0.2s;
      }
      .file-info-overlay a:hover {
        opacity: 0.8;
        text-decoration: underline;
      }
      .info-copy-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #ff6b6b;
        padding: 0.1rem 0.4rem;
        border-radius: 4px;
        font-size: 0.8rem;
        cursor: pointer;
        margin-left: 0.5rem;
        transition: background 0.2s;
      }
      .info-copy-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }
      .folder-filter-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        z-index: 2500;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .folder-filter-modal.visible {
        display: flex;
        opacity: 1;
      }
      .folder-filter-content {
        background: rgba(20, 20, 20, 0.98);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        max-width: 600px;
        max-height: 80vh;
        min-width: 400px;
        display: flex;
        flex-direction: column;
      }
      .folder-filter-header {
        padding: 2rem 2rem 0 2rem;
        position: sticky;
        top: 0;
        background: rgba(20, 20, 20, 0.98);
        z-index: 10;
        border-radius: 12px 12px 0 0;
      }
      .folder-filter-content h2 {
        margin-bottom: 1rem;
        font-size: 1.5rem;
        font-weight: 600;
      }
      .folder-filter-actions {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        flex-wrap: wrap;
      }
      .folder-filter-scroll {
        overflow-y: auto;
        padding: 0 2rem 2rem 2rem;
      }
      .folder-filter-actions button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: background 0.2s;
      }
      .folder-filter-actions button:hover {
        background: rgba(255, 255, 255, 0.15);
      }
      .folder-filter-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .folder-filter-actions button:disabled:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      #enableOnlyCurrentFolder {
        background: rgba(255, 107, 107, 0.2);
        border-color: rgba(255, 107, 107, 0.3);
      }
      #enableOnlyCurrentFolder:hover:not(:disabled) {
        background: rgba(255, 107, 107, 0.3);
      }
      .folder-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .folder-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem;
        border-radius: 6px;
        transition: background 0.2s;
        cursor: pointer;
      }
      .folder-item:hover {
        background: rgba(255, 255, 255, 0.05);
      }
      .folder-item.current-folder {
        background: rgba(255, 107, 107, 0.15);
        border: 1px solid rgba(255, 107, 107, 0.3);
      }
      .folder-item.current-folder:hover {
        background: rgba(255, 107, 107, 0.2);
      }
      .folder-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #ff6b6b;
      }
      .folder-item label {
        flex: 1;
        cursor: pointer;
        font-size: 0.95rem;
        word-break: break-all;
      }
      .folder-item-count {
        opacity: 0.6;
        font-size: 0.85rem;
        margin-left: auto;
        padding-left: 1rem;
      }
      .goto-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        z-index: 2500;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .goto-modal.visible {
        display: flex;
        opacity: 1;
      }
      .goto-modal-content {
        background: rgba(20, 20, 20, 0.98);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 2rem;
        min-width: 300px;
      }
      .goto-modal-content h2 {
        margin-bottom: 1rem;
        font-size: 1.5rem;
        font-weight: 600;
      }
      .goto-modal-content input {
        width: 100%;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.75rem;
        border-radius: 6px;
        font-size: 1.2rem;
        text-align: center;
      }
      .goto-modal-content input:focus {
        outline: none;
        border-color: #ff6b6b;
      }
      .goto-modal-hint {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        opacity: 0.6;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1 id="title">Grid Viewer</h1>
      <div class="controls">
        <span
          >Zoom:
          <input
            type="range"
            id="zoom-slider"
            min="6"
            max="40"
            value="18"
            step="2"
        /></span>
        <span
          >Auto-scroll speed:
          <input
            type="range"
            id="auto-scroll-speed"
            min="0"
            max="200"
            value="0"
            step="10"
        /></span>
        <span
          >Sort:
          <select id="sort-order">
            <option value="filename-asc">Filename A-Z</option>
            <option value="filename-desc">Filename Z-A</option>
            <option value="mtime-newest">Newest First</option>
            <option value="mtime-oldest">Oldest First</option>
            <option value="mtime-newest-interleaved">
              Newest First (Interleaved)
            </option>
            <option value="dir-newest">Folders: Newest First</option>
            <option value="dir-oldest">Folders: Oldest First</option>
            <option value="dir-newest-interleaved">
              Folders: Newest (Interleaved)
            </option>
            <option value="random">Random</option>
            <option value="random-blocks">Random (Blocks)</option>
            <option value="random-interleaved">Random (Interleaved)</option>
          </select></span
        >
        <span
          >Type:
          <select id="media-type-filter">
            <option value="all">All</option>
            <option value="video">Videos</option>
            <option value="image">Images</option>
          </select></span
        >
        <div class="shortcuts-container">
          <button class="shortcuts-toggle" id="shortcuts-toggle">
            Shortcuts
          </button>
          <div class="shortcuts-list" id="shortcuts-list">
            <span>Arrows/WASD to navigate</span>
            <span>Space/X to maximize</span>
            <span>Q/E seek video (1s/3s/15s)</span>
            <span>M to mute/unmute video</span>
            <span>C to center on selected</span>
            <span>Z/V prev/next folder</span>
            <span>I for info</span>
            <span>F for folder filter</span>
            <span>G to go to item/filename</span>
            <span>ESC to close</span>
          </div>
        </div>
      </div>
    </div>

    <div class="drop-zone" id="dropZone">
      <h2>Drop a PGrid File</h2>
      <p>
        Drag and drop a <code>_pgrid.jpg</code> file generated by grid.ts to
        view the media collection
      </p>
    </div>

    <div class="masonry-grid" id="grid"></div>

    <div class="fullscreen-overlay" id="fullscreen">
      <div class="fullscreen-content" id="fullscreen-media"></div>
    </div>

    <div class="scroll-indicator" id="scrollIndicator">
      <span id="currentIndex">0</span> / <span id="totalCount">0</span>
    </div>

    <div class="file-info-overlay" id="fileInfoOverlay">
      <div class="info-line">
        <span class="info-label">File:</span>
        <span id="infoFilename">-</span>
        <a
          id="infoFileLink"
          href="#"
          target="_blank"
          style="margin-left: 0.5rem"
          >[open]</a
        >
        <button class="info-copy-btn" id="infoCopyBtn">[copy]</button>
      </div>
      <div class="info-line">
        <span class="info-label">Dimensions:</span>
        <span id="infoDimensions">-</span>
      </div>
      <div class="info-line">
        <span class="info-label">Type:</span>
        <span id="infoType">-</span>
      </div>
    </div>

    <div class="folder-filter-modal" id="folderFilterModal">
      <div class="folder-filter-content">
        <div class="folder-filter-header">
          <h2>Filter Folders</h2>
          <div class="folder-filter-actions">
            <button id="enableAllFolders">Enable All</button>
            <button id="disableAllFolders">Disable All</button>
            <button id="enableOnlyCurrentFolder">Enable Only Current</button>
          </div>
        </div>
        <div class="folder-filter-scroll">
          <div class="folder-list" id="folderList"></div>
        </div>
      </div>
    </div>

    <div class="goto-modal" id="gotoModal">
      <div class="goto-modal-content">
        <h2>Go to Item</h2>
        <input
          type="text"
          id="gotoInput"
          placeholder="Item number or filename"
        />
        <div class="goto-modal-hint">Press Enter to go, ESC to cancel</div>
      </div>
    </div>

    <script>
      // ========== State Management ==========
      let mediaData = [];
      let unfilteredMediaData = [];
      let baseDirectory = "";
      let currentSortOrder = "filename-asc";
      let directoryBirthtimes = {}; // Map of relative path -> birthtime

      // Selection & Navigation
      let currentIndex = 0;
      let previousIndex = 0;
      let isFullscreen = false;
      let showFileInfo = false;

      // Virtual Scrolling
      let layoutData = [];
      let renderedItems = new Map(); // index -> DOM element
      const RENDER_BUFFER = 2000; // px buffer above/below viewport

      // Media Loading
      let loadedItems = new Set();
      let visibleItems = new Set();
      let observer = null;
      let loadDebounceTimer = null;
      let videoTimes = new Map();

      // Folder Filtering
      let enabledFolders = new Set();
      let allFolders = [];

      // Media Type Filtering
      let mediaTypeFilter = "all"; // "all", "video", "image"

      // Auto-scroll
      let autoScrollTimer = null;
      let autoScrollSpeed;

      // Initialization
      let globalListenersInitialized = false;

      // ========== Drop Zone & File Loading ==========

      function setupDropZone() {
        const dropZone = document.getElementById("dropZone");

        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        ["dragenter", "dragover"].forEach((eventName) => {
          dropZone.addEventListener(eventName, highlight, false);
        });

        ["dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
          dropZone.classList.add("drag-over");
        }

        function unhighlight(e) {
          dropZone.classList.remove("drag-over");
        }

        dropZone.addEventListener("drop", handleDrop, false);

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;

          if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith("_pgrid.jpg")) {
              processPgridFile(file);
            } else {
              alert("Please drop a _pgrid.jpg file");
            }
          }
        }

        // Allow dropping a new file anywhere on the page
        // Show drop zone when dragging over the document
        document.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dropZone.classList.remove("hidden");
        });

        document.addEventListener("dragover", (e) => {
          e.preventDefault();
        });

        document.addEventListener("dragleave", (e) => {
          e.preventDefault();
          // Only hide when actually leaving the document (relatedTarget is null)
          if (e.relatedTarget === null && mediaData.length > 0) {
            dropZone.classList.add("hidden");
          }
        });

        document.addEventListener("drop", (e) => {
          e.preventDefault();
          // Hide drop zone if we have media loaded (will show again if new file is processed)
          if (mediaData.length > 0) {
            dropZone.classList.add("hidden");
          }
        });
      }

      async function processPgridFile(file) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          const fileText = new TextDecoder().decode(uint8Array);

          // Look for metadata markers
          const startMarker = "<!--PGGRID_METADATA:";
          const endMarker = "-->";
          const startIndex = fileText.lastIndexOf(startMarker);

          if (startIndex === -1) {
            alert("Could not find metadata in the pgrid file");
            return;
          }

          const endIndex = fileText.indexOf(endMarker, startIndex);
          if (endIndex === -1) {
            alert("Invalid metadata format in the pgrid file");
            return;
          }

          // Extract and parse JSON
          const jsonStart = startIndex + startMarker.length;
          const jsonText = fileText.substring(jsonStart, endIndex);

          let cacheData;
          let dirBirthtimes = {};
          let pgridVersion = 1;
          try {
            const parsed = JSON.parse(jsonText);
            // Handle both old format (direct cache) and new format (with version/files/directories)
            if (parsed.version) {
              pgridVersion = parsed.version;
              cacheData = parsed.files;
              dirBirthtimes = parsed.directories || {};
            } else {
              // Old format (v1): the parsed object is the cache directly
              cacheData = parsed;
            }
          } catch {
            alert("Invalid JSON metadata in the pgrid file");
            return;
          }

          console.log(
            `ðŸ“Š Loading ${Object.keys(cacheData).length} items from pgrid (v${pgridVersion})`,
          );
          initializeViewer(cacheData, file.name, dirBirthtimes);
        } catch (e) {
          console.error("Error processing pgrid file:", e);
          alert("Error processing the pgrid file");
        }
      }

      function initializeViewer(cacheData, filename, dirBirthtimes = {}) {
        // Reset state from previous file
        if (observer) observer.disconnect();
        loadedItems.clear();
        visibleItems.clear();
        videoTimes.clear();
        renderedItems.clear();
        currentIndex = 0;
        previousIndex = 0;
        layoutData = [];
        if (loadDebounceTimer) {
          clearTimeout(loadDebounceTimer);
          loadDebounceTimer = null;
        }
        stopAutoScroll();

        // Reset media type filter
        mediaTypeFilter = "all";
        document.getElementById("media-type-filter").value = "all";

        // Store directory birthtimes
        directoryBirthtimes = dirBirthtimes;

        // Extract directory name
        const dirName = filename.replace("_pgrid.jpg", "");
        baseDirectory = dirName;

        // Convert cache data to media items
        mediaData = Object.entries(cacheData).map(([name, data]) => {
          const mimeType = getMimeType(name);
          const type = mimeType.startsWith("video/") ? "video" : "image";
          return {
            name,
            size: data.size,
            mimeType,
            type,
            mtime: data.mtime || 0,
          };
        });

        // Setup folder filtering (all enabled by default)
        allFolders = extractUniqueFolders(mediaData);
        enabledFolders = new Set(allFolders);

        // Apply sort order
        const sortOrder = document.getElementById("sort-order").value;
        currentSortOrder = sortOrder;
        applySortOrder(sortOrder);
        unfilteredMediaData = [...mediaData];

        // Update UI
        document.getElementById("dropZone").classList.add("hidden");
        document.getElementById("title").textContent = dirName;
        document.title = dirName;

        // Initialize virtual grid
        generateMediaItems();
        window.scrollTo(0, 0);
        initializeViewerComponents();

        console.log(`âœ… Initialized with ${mediaData.length} items`);
      }

      // ========== MIME Type Detection ==========

      const MIME_TYPES = {
        // Video formats
        mp4: "video/mp4",
        avi: "video/x-msvideo",
        mov: "video/quicktime",
        mkv: "video/x-matroska",
        webm: "video/webm",
        flv: "video/x-flv",
        wmv: "video/x-ms-wmv",
        m4v: "video/x-m4v",
        "3gp": "video/3gpp",
        "3g2": "video/3gpp2",
        ogv: "video/ogg",
        ts: "video/mp2t",
        mts: "video/mp2t",
        m2ts: "video/mp2t",
        vob: "video/mpeg",
        asf: "video/x-ms-asf",
        divx: "video/x-msvideo",
        xvid: "video/x-msvideo",
        f4v: "video/x-f4v",
        mpg: "video/mpeg",
        mpeg: "video/mpeg",
        mpe: "video/mpeg",
        m1v: "video/mpeg",
        m2v: "video/mpeg",
        mpv: "video/mp4",
        mpv2: "video/mp4",
        m4s: "video/mp4",
        m4b: "audio/mp4",
        m4a: "audio/mp4",
        m4p: "audio/mp4",
        m4r: "audio/mp4",
        // Image formats
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        png: "image/png",
        gif: "image/gif",
        bmp: "image/bmp",
        webp: "image/webp",
        svg: "image/svg+xml",
        ico: "image/x-icon",
        tiff: "image/tiff",
        tif: "image/tiff",
        jxl: "image/jxl",
        jp2: "image/jp2",
        jpx: "image/jpx",
        jpm: "image/jpm",
        jpf: "image/jpx",
        heic: "image/heic",
        heif: "image/heif",
        avif: "image/avif",
      };

      function getMimeType(filename) {
        const ext = filename.toLowerCase().split(".").pop();
        return MIME_TYPES[ext] || "application/octet-stream";
      }

      // ========== Sorting & Filtering ==========

      function applySortOrder(sortOrder) {
        switch (sortOrder) {
          case "filename-asc":
            mediaData.sort((a, b) => a.name.localeCompare(b.name));
            break;
          case "filename-desc":
            mediaData.sort((a, b) => b.name.localeCompare(a.name));
            break;
          case "mtime-newest":
            // Sort by modified time (newest first)
            mediaData.sort((a, b) => {
              const timeA = a.mtime || 0;
              const timeB = b.mtime || 0;
              return timeB - timeA;
            });
            break;
          case "mtime-oldest":
            // Sort by modified time (oldest first)
            mediaData.sort((a, b) => {
              const timeA = a.mtime || 0;
              const timeB = b.mtime || 0;
              return timeA - timeB;
            });
            break;
          case "mtime-newest-interleaved":
            // Group by folder, sort folders by newest file, then interleave files
            const folderGroupsNewest = new Map();

            // Group items by folder (everything before the last '/')
            mediaData.forEach((item) => {
              const lastSlash = item.name.lastIndexOf("/");
              const folder =
                lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
              if (!folderGroupsNewest.has(folder)) {
                folderGroupsNewest.set(folder, []);
              }
              folderGroupsNewest.get(folder).push(item);
            });

            // Sort items within each folder by mtime (newest first)
            folderGroupsNewest.forEach((items) => {
              items.sort((a, b) => {
                const timeA = a.mtime || 0;
                const timeB = b.mtime || 0;
                return timeB - timeA;
              });
            });

            // Sort folders by their newest file's mtime
            const foldersNewest = Array.from(folderGroupsNewest.keys()).sort(
              (a, b) => {
                const newestA = folderGroupsNewest.get(a)[0]?.mtime || 0;
                const newestB = folderGroupsNewest.get(b)[0]?.mtime || 0;
                return newestB - newestA;
              },
            );

            // Interleave files: take file 0 from each folder, then file 1, etc.
            mediaData = [];
            const folderArrays = foldersNewest.map((folder) =>
              folderGroupsNewest.get(folder),
            );
            const maxLength = Math.max(
              ...folderArrays.map((arr) => arr.length),
            );

            for (let i = 0; i < maxLength; i++) {
              folderArrays.forEach((items) => {
                if (i < items.length) {
                  mediaData.push(items[i]);
                }
              });
            }
            break;
          case "dir-newest":
            // Sort by folder birthtime (newest folders first), then by filename within folder
            mediaData.sort((a, b) => {
              const folderA = getFolderFromItem(a);
              const folderB = getFolderFromItem(b);
              const birthtimeA = directoryBirthtimes[folderA] || 0;
              const birthtimeB = directoryBirthtimes[folderB] || 0;
              if (birthtimeA !== birthtimeB) {
                return birthtimeB - birthtimeA; // Newest first
              }
              return a.name.localeCompare(b.name);
            });
            break;
          case "dir-oldest":
            // Sort by folder birthtime (oldest folders first), then by filename within folder
            mediaData.sort((a, b) => {
              const folderA = getFolderFromItem(a);
              const folderB = getFolderFromItem(b);
              const birthtimeA = directoryBirthtimes[folderA] || 0;
              const birthtimeB = directoryBirthtimes[folderB] || 0;
              if (birthtimeA !== birthtimeB) {
                return birthtimeA - birthtimeB; // Oldest first
              }
              return a.name.localeCompare(b.name);
            });
            break;
          case "dir-newest-interleaved":
            // Group by folder, sort folders by birthtime (newest first), then interleave files
            const folderGroupsBirthtime = new Map();

            // Group items by folder
            mediaData.forEach((item) => {
              const folder = getFolderFromItem(item);
              if (!folderGroupsBirthtime.has(folder)) {
                folderGroupsBirthtime.set(folder, []);
              }
              folderGroupsBirthtime.get(folder).push(item);
            });

            // Sort items within each folder by filename
            folderGroupsBirthtime.forEach((items) => {
              items.sort((a, b) => a.name.localeCompare(b.name));
            });

            // Sort folders by birthtime (newest first)
            const foldersByBirthtime = Array.from(
              folderGroupsBirthtime.keys(),
            ).sort((a, b) => {
              const birthtimeA = directoryBirthtimes[a] || 0;
              const birthtimeB = directoryBirthtimes[b] || 0;
              return birthtimeB - birthtimeA;
            });

            // Interleave files: take file 0 from each folder, then file 1, etc.
            mediaData = [];
            const folderArraysBirthtime = foldersByBirthtime.map((folder) =>
              folderGroupsBirthtime.get(folder),
            );
            const maxLengthBirthtime = Math.max(
              ...folderArraysBirthtime.map((arr) => arr.length),
            );

            for (let i = 0; i < maxLengthBirthtime; i++) {
              folderArraysBirthtime.forEach((items) => {
                if (i < items.length) {
                  mediaData.push(items[i]);
                }
              });
            }
            break;
          case "random":
            // Fisher-Yates shuffle
            for (let i = mediaData.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [mediaData[i], mediaData[j]] = [mediaData[j], mediaData[i]];
            }
            break;
          case "random-blocks":
            // Group by folder, randomize groups, then randomize within each group
            const folderGroupsBlocks = new Map();

            // Group items by folder (everything before the last '/')
            mediaData.forEach((item) => {
              const lastSlash = item.name.lastIndexOf("/");
              const folder =
                lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
              if (!folderGroupsBlocks.has(folder)) {
                folderGroupsBlocks.set(folder, []);
              }
              folderGroupsBlocks.get(folder).push(item);
            });

            // Convert to array and shuffle the folders
            const foldersBlocks = Array.from(folderGroupsBlocks.keys());
            for (let i = foldersBlocks.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [foldersBlocks[i], foldersBlocks[j]] = [
                foldersBlocks[j],
                foldersBlocks[i],
              ];
            }

            // Shuffle items within each folder and rebuild mediaData
            mediaData = [];
            foldersBlocks.forEach((folder) => {
              const items = folderGroupsBlocks.get(folder);
              // Fisher-Yates shuffle within the folder
              for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [items[i], items[j]] = [items[j], items[i]];
              }
              mediaData.push(...items);
            });
            break;
          case "random-interleaved":
            // Group by folder, randomize groups, randomize within each group, then interleave
            const folderGroupsInterleaved = new Map();

            // Group items by folder (everything before the last '/')
            mediaData.forEach((item) => {
              const lastSlash = item.name.lastIndexOf("/");
              const folder =
                lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
              if (!folderGroupsInterleaved.has(folder)) {
                folderGroupsInterleaved.set(folder, []);
              }
              folderGroupsInterleaved.get(folder).push(item);
            });

            // Shuffle items within each folder
            folderGroupsInterleaved.forEach((items) => {
              // Fisher-Yates shuffle within the folder
              for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [items[i], items[j]] = [items[j], items[i]];
              }
            });

            // Convert to array and shuffle the folders
            const foldersInterleaved = Array.from(
              folderGroupsInterleaved.keys(),
            );
            for (let i = foldersInterleaved.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [foldersInterleaved[i], foldersInterleaved[j]] = [
                foldersInterleaved[j],
                foldersInterleaved[i],
              ];
            }

            // Interleave files: take file 0 from each folder, then file 1, etc.
            mediaData = [];
            const folderArraysInterleaved = foldersInterleaved.map((folder) =>
              folderGroupsInterleaved.get(folder),
            );
            const maxLengthInterleaved = Math.max(
              ...folderArraysInterleaved.map((arr) => arr.length),
            );

            for (let i = 0; i < maxLengthInterleaved; i++) {
              folderArraysInterleaved.forEach((items) => {
                if (i < items.length) {
                  mediaData.push(items[i]);
                }
              });
            }
            break;
        }
      }

      function extractUniqueFolders(data) {
        const folders = new Set();
        data.forEach((item) => {
          const lastSlash = item.name.lastIndexOf("/");
          const folder =
            lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
          folders.add(folder);
        });
        return Array.from(folders).sort();
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function getFolderFromItem(item) {
        const lastSlash = item.name.lastIndexOf("/");
        return lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
      }

      function goToNextFolder() {
        if (mediaData.length === 0) return;
        const currentFolder = getFolderFromItem(mediaData[currentIndex]);
        
        // Find next item with a different folder
        for (let i = currentIndex + 1; i < mediaData.length; i++) {
          if (getFolderFromItem(mediaData[i]) !== currentFolder) {
            currentIndex = i;
            updateSelection();
            updateScrollIndicator();
            scrollToCurrent();
            updateFileInfo();
            return;
          }
        }
      }

      function goToPreviousFolder() {
        if (mediaData.length === 0) return;
        const currentFolder = getFolderFromItem(mediaData[currentIndex]);
        
        // First, go back to find a different folder
        let differentFolderIndex = -1;
        for (let i = currentIndex - 1; i >= 0; i--) {
          if (getFolderFromItem(mediaData[i]) !== currentFolder) {
            differentFolderIndex = i;
            break;
          }
        }
        
        if (differentFolderIndex === -1) return; // No previous folder
        
        // Now find the first item of that folder
        const targetFolder = getFolderFromItem(mediaData[differentFolderIndex]);
        for (let i = differentFolderIndex; i >= 0; i--) {
          if (getFolderFromItem(mediaData[i]) !== targetFolder) {
            currentIndex = i + 1;
            updateSelection();
            updateScrollIndicator();
            scrollToCurrent();
            updateFileInfo();
            return;
          }
        }
        
        // The target folder starts at index 0
        currentIndex = 0;
        updateSelection();
        updateScrollIndicator();
        scrollToCurrent();
        updateFileInfo();
      }

      function applyFilters() {
        // Filter mediaData by enabled folders and media type
        mediaData = unfilteredMediaData.filter((item) => {
          const folder = getFolderFromItem(item);
          const folderOk = enabledFolders.has(folder);
          const typeOk = mediaTypeFilter === "all" || item.type === mediaTypeFilter;
          return folderOk && typeOk;
        });

        // Clear and regenerate the virtual grid
        generateMediaItems();

        // Recalculate layout (this will also call updateVirtualItems)
        calculateLayout();

        // Reset current index to 0 when filter changes
        currentIndex = 0;
        previousIndex = 0;
        updateSelection();
        updateScrollIndicator();
        updateFileInfo();

        // Re-setup virtualization observer
        if (observer) {
          observer.disconnect();
        }
        setupVirtualization();

        // Clear loaded items cache
        loadedItems.clear();
        visibleItems.clear();

        // Scroll to top and force load visible items
        window.scrollTo(0, 0);
        setTimeout(forceLoadVisibleItems, 100);
      }

      function openFolderFilterModal() {
        const modal = document.getElementById("folderFilterModal");
        const folderList = document.getElementById("folderList");

        // Get current folder of selected item
        const currentFolder = mediaData[currentIndex]
          ? getFolderFromItem(mediaData[currentIndex])
          : null;

        // Count items per folder from unfilteredMediaData
        const folderCounts = new Map();
        unfilteredMediaData.forEach((item) => {
          const folder = getFolderFromItem(item);
          folderCounts.set(folder, (folderCounts.get(folder) || 0) + 1);
        });

        // Update header with current/total counts
        const enabledCount = Array.from(enabledFolders).reduce(
          (sum, folder) => {
            return sum + (folderCounts.get(folder) || 0);
          },
          0,
        );
        const totalCount = unfilteredMediaData.length;
        modal.querySelector("h2").textContent =
          `Filter Folders (${enabledCount}/${totalCount} items)`;

        // Build folder list HTML
        const foldersHTML = allFolders
          .map((folder, index) => {
            const isEnabled = enabledFolders.has(folder);
            const isCurrent = folder === currentFolder;
            const count = folderCounts.get(folder) || 0;
            const displayName = folder || "(root)";

            return `
            <div class="folder-item ${isCurrent ? "current-folder" : ""}" data-folder-index="${index}">
              <input type="checkbox" data-folder-index="${index}" ${isEnabled ? "checked" : ""}>
              <label>${escapeHtml(displayName)}</label>
              <span class="folder-item-count">${count}</span>
            </div>
          `;
          })
          .join("");

        folderList.innerHTML = foldersHTML;

        // Add event listeners to checkboxes and folder items
        allFolders.forEach((folder, index) => {
          const folderItem = folderList.querySelector(
            `[data-folder-index="${index}"]`,
          );
          const checkbox = folderItem.querySelector('input[type="checkbox"]');

          // Click on folder item toggles checkbox
          folderItem.addEventListener("click", (e) => {
            if (e.target.tagName !== "INPUT") {
              checkbox.checked = !checkbox.checked;
              handleFolderToggle(folder, checkbox.checked);
            }
          });

          // Checkbox change
          checkbox.addEventListener("change", (e) => {
            handleFolderToggle(folder, e.target.checked);
          });
        });

        modal.classList.add("visible");

        // Enable/disable "Enable Only Current" button based on whether there's a current folder
        const enableOnlyCurrentBtn = document.getElementById(
          "enableOnlyCurrentFolder",
        );
        if (currentFolder !== null) {
          enableOnlyCurrentBtn.disabled = false;

          // Scroll to current folder if it's not visible
          const currentFolderIdx = allFolders.indexOf(currentFolder);
          if (currentFolderIdx !== -1) {
            const currentFolderItem = folderList.querySelector(
              `[data-folder-index="${currentFolderIdx}"]`,
            );
            if (currentFolderItem) {
              setTimeout(() => {
                const scrollContainer = modal.querySelector(
                  ".folder-filter-scroll",
                );
                const itemTop = currentFolderItem.offsetTop;
                const itemBottom = itemTop + currentFolderItem.offsetHeight;
                const containerHeight = scrollContainer.clientHeight;
                const scrollTop = scrollContainer.scrollTop;

                // Check if item is not fully visible
                if (
                  itemTop < scrollTop ||
                  itemBottom > scrollTop + containerHeight
                ) {
                  // Scroll to center the item
                  scrollContainer.scrollTop =
                    itemTop -
                    containerHeight / 2 +
                    currentFolderItem.offsetHeight / 2;
                }
              }, 50);
            }
          }
        } else {
          enableOnlyCurrentBtn.disabled = true;
        }
      }

      function closeFolderFilterModal() {
        const modal = document.getElementById("folderFilterModal");
        modal.classList.remove("visible");
      }

      function handleFolderToggle(folder, isEnabled) {
        if (isEnabled) {
          enabledFolders.add(folder);
        } else {
          enabledFolders.delete(folder);
        }
        applyFilters();
      }

      function sortMediaItems() {
        const sortOrder = document.getElementById("sort-order").value;
        currentSortOrder = sortOrder;

        // Sort the unfiltered data first
        mediaData = [...unfilteredMediaData];
        applySortOrder(sortOrder);
        unfilteredMediaData = [...mediaData];

        // Then apply filters
        applyFilters();
      }

      function applyMediaTypeFilter() {
        mediaTypeFilter = document.getElementById("media-type-filter").value;
        applyFilters();
      }

      function openGotoModal() {
        const modal = document.getElementById("gotoModal");
        const input = document.getElementById("gotoInput");

        input.value = "";
        modal.classList.add("visible");

        // Focus input after modal is visible
        setTimeout(() => input.focus(), 100);
      }

      function closeGotoModal() {
        const modal = document.getElementById("gotoModal");
        modal.classList.remove("visible");
      }

      function gotoItemByNumberOrName(query) {
        query = query.trim();
        if (!query) return;

        // Try parsing as a number first
        const itemNumber = parseInt(query);
        if (!isNaN(itemNumber) && itemNumber >= 1 && itemNumber <= mediaData.length) {
          // Go to item by number (1-based)
          currentIndex = itemNumber - 1;
          updateScrollIndicator();
          scrollToCurrent(false);
          updateFileInfo();
          closeGotoModal();
          return;
        }

        // Extract basename if query looks like a path
        let searchTerm = query;
        if (query.includes("/")) {
          searchTerm = query.substring(query.lastIndexOf("/") + 1);
        }

        // Search by filename (case-insensitive, partial match)
        const lowerQuery = searchTerm.toLowerCase();
        const foundIndex = mediaData.findIndex((item) => {
          // Get the basename of the item for comparison
          const itemBasename = item.name.substring(item.name.lastIndexOf("/") + 1);
          return itemBasename.toLowerCase().includes(lowerQuery);
        });

        if (foundIndex !== -1) {
          currentIndex = foundIndex;
          updateScrollIndicator();
          scrollToCurrent(false);
          updateFileInfo();
          closeGotoModal();
        }
      }

      // ========== Virtual Scrolling & DOM Management ==========

      function generateMediaItems() {
        const grid = document.getElementById("grid");
        // Clear existing rendered items
        grid.innerHTML = "";
        renderedItems.clear();

        // Container will have its height set by calculateLayout
        // Individual items will be created by updateVirtualItems
      }

      function createItemElement(index) {
        const media = mediaData[index];
        const div = document.createElement("div");
        div.className = "media-item virtualized";

        // Apply selected class if this is the current item
        if (index === currentIndex) {
          div.classList.add("selected");
        }

        // Set data attributes
        Object.assign(div.dataset, {
          index,
          type: media.type,
          name: media.name,
          src: `${baseDirectory}/${media.name}`,
          mimeType: media.mimeType,
        });

        // Set aspect ratio if available
        if (media.size.width > 0 && media.size.height > 0) {
          div.style.aspectRatio = `${media.size.width} / ${media.size.height}`;
        }

        // Add placeholder
        const placeholder = document.createElement("div");
        placeholder.className = "media-placeholder";
        placeholder.textContent = "Virtualized";
        div.appendChild(placeholder);

        // Event handlers
        div.addEventListener("click", () => {
          currentIndex = index;
          updateSelection();
          updateScrollIndicator();
          scrollToCurrent(); // Smooth scroll for clicks
          updateFileInfo();
        });

        div.addEventListener("dblclick", () => {
          currentIndex = index;
          updateSelection();
          updateScrollIndicator();
          openFullscreen();
        });

        return div;
      }

      function updateVirtualItems() {
        if (layoutData.length === 0) return;

        const scrollTop = window.scrollY;
        const viewportHeight = window.innerHeight;
        const renderStart = Math.max(0, scrollTop - RENDER_BUFFER);
        const renderEnd = scrollTop + viewportHeight + RENDER_BUFFER;

        // Find which items should be rendered
        const shouldRender = new Set();
        for (let i = 0; i < layoutData.length; i++) {
          const layout = layoutData[i];
          if (
            layout.y + layout.height >= renderStart &&
            layout.y <= renderEnd
          ) {
            shouldRender.add(i);
          }
        }

        // Remove items that shouldn't be rendered anymore
        const grid = document.getElementById("grid");
        for (const [index, element] of renderedItems.entries()) {
          if (!shouldRender.has(index)) {
            if (observer) observer.unobserve(element);
            grid.removeChild(element);
            renderedItems.delete(index);
            // Also mark as not loaded since the DOM element is being removed
            loadedItems.delete(index);
            visibleItems.delete(index);
          }
        }

        // Add/update items that should be rendered
        for (const index of shouldRender) {
          const layout = layoutData[index];

          if (!renderedItems.has(index)) {
            // Create new item
            const element = createItemElement(index);

            // Apply layout position and size
            element.style.left = layout.x + "px";
            element.style.top = layout.y + "px";
            element.style.width = layout.width + "px";
            element.style.height = layout.height + "px";

            grid.appendChild(element);
            renderedItems.set(index, element);

            if (observer) observer.observe(element);
          } else {
            // Update existing item's layout (important for zoom changes)
            const element = renderedItems.get(index);
            element.style.left = layout.x + "px";
            element.style.top = layout.y + "px";
            element.style.width = layout.width + "px";
            element.style.height = layout.height + "px";
          }
        }

        // Debug: log render efficiency (only if changed significantly)
        const renderRatio = shouldRender.size / layoutData.length;
        if (renderRatio < 0.1) {
          console.log(
            `ðŸ–¼ï¸ Rendering ${shouldRender.size}/${layoutData.length} items (${(renderRatio * 100).toFixed(1)}%)`,
          );
        }
      }

      function initializeViewerComponents() {
        // Apply current zoom level
        const zoomSlider = document.getElementById("zoom-slider");
        document.documentElement.style.setProperty(
          "--item-width",
          zoomSlider.value + "vw",
        );

        // Calculate layout and render initial items
        calculateLayout();

        // Update UI state
        updateSelection();
        updateScrollIndicator();
        updateFileInfo();

        // Setup media loading observer
        setupVirtualization();

        // Force initial load check for visible items
        setTimeout(forceLoadVisibleItems, 100);

        // Restore auto-scroll if enabled
        const speed = Number(
          document.getElementById("auto-scroll-speed").value,
        );
        if (speed > 0) {
          stopAutoScroll();
          startAutoScroll();
        }

        // Setup global event listeners (only once)
        if (!globalListenersInitialized) {
          globalListenersInitialized = true;
          setupGlobalListeners();
        }
      }

      function setupGlobalListeners() {
        window.addEventListener("resize", () => {
          calculateLayout();
          setTimeout(forceLoadVisibleItems, 100);
        });

        // Virtual scroll update on scroll
        let scrollTimeout;
        window.addEventListener(
          "scroll",
          () => {
            if (scrollTimeout) clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateVirtualItems, 50);
          },
          { passive: true },
        );

        // Zoom slider with debouncing
        let zoomTimeout;
        document
          .getElementById("zoom-slider")
          .addEventListener("input", (e) => {
            document.documentElement.style.setProperty(
              "--item-width",
              e.target.value + "vw",
            );

            // Debounce the expensive operations
            if (zoomTimeout) clearTimeout(zoomTimeout);
            zoomTimeout = setTimeout(() => {
              calculateLayout();
              setTimeout(forceLoadVisibleItems, 100);
            }, 150);
          });

        // Auto-scroll speed
        autoScrollSpeed = document.getElementById("auto-scroll-speed");
        autoScrollSpeed.addEventListener("input", () => {
          const speed = Number(autoScrollSpeed.value);
          if (speed > 0) {
            stopAutoScroll();
            startAutoScroll();
          } else {
            stopAutoScroll();
          }
        });

        // Sort order
        document
          .getElementById("sort-order")
          .addEventListener("change", sortMediaItems);

        // Media type filter
        document
          .getElementById("media-type-filter")
          .addEventListener("change", applyMediaTypeFilter);
      }

      function setupVirtualization() {
        observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const index = parseInt(entry.target.dataset.index);
              if (entry.isIntersecting) {
                visibleItems.add(index);
              } else {
                visibleItems.delete(index);
              }
            });

            // Debounce media loading
            if (loadDebounceTimer) clearTimeout(loadDebounceTimer);
            loadDebounceTimer = setTimeout(() => {
              visibleItems.forEach((index) => {
                if (!loadedItems.has(index)) loadMediaItem(index);
              });
            }, 150);
          },
          { rootMargin: "300px" },
        );
      }

      // ========== Media Loading ==========

      function forceLoadVisibleItems() {
        // Load all currently rendered items (they're already in DOM, might as well load the media)
        renderedItems.forEach((element, index) => {
          if (!loadedItems.has(index)) {
            loadMediaItem(index);
          }
        });
      }

      function loadMediaItem(index) {
        if (loadedItems.has(index)) return;

        const item = renderedItems.get(index);
        if (!item) return;

        const placeholder = item.querySelector(".media-placeholder");
        placeholder.textContent = "Loading...";

        loadedItems.add(index);
        item.classList.remove("virtualized");

        const { type, src } = item.dataset;

        if (type === "image") {
          const img = document.createElement("img");
          img.src = src;
          img.onload = () => item.classList.add("loaded");
          img.onerror = () => {
            if (placeholder) placeholder.textContent = "Failed to load";
            item.classList.add("loaded");
          };
          item.appendChild(img);
        } else if (type === "video") {
          const video = document.createElement("video");
          video.src = src;
          video.muted = true;
          video.loop = true;
          video.playsInline = true;
          video.autoplay = true;

          // Create time overlay (hidden until metadata loads)
          const timeOverlay = document.createElement("div");
          timeOverlay.className = "video-time-overlay";
          timeOverlay.style.display = "none";
          item.appendChild(timeOverlay);

          function formatTime(seconds) {
            if (!isFinite(seconds) || seconds < 0) return "--:--";
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, "0")}`;
          }

          video.addEventListener("timeupdate", () => {
            if (!video.paused) videoTimes.set(index, video.currentTime);
            timeOverlay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
          });
          video.addEventListener("loadedmetadata", () => {
            timeOverlay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
            timeOverlay.style.display = "";
          });
          video.onloadeddata = () => item.classList.add("loaded");
          video.onerror = () => {
            if (placeholder) placeholder.textContent = "Failed to load";
            item.classList.add("loaded");
          };
          item.appendChild(video);
        }
      }

      // ========== Layout Calculation ==========

      function calculateLayout() {
        const grid = document.getElementById("grid");
        const gap = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue("--gap"),
        );
        const itemWidthVW = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--item-width",
          ),
        );
        const itemWidthPx = (itemWidthVW / 100) * window.innerWidth;

        const containerWidth = grid.clientWidth;
        const numColumns = Math.max(
          1,
          Math.round(containerWidth / itemWidthPx),
        );
        const colWidth = (containerWidth - (numColumns + 1) * gap) / numColumns;

        const colHeights = Array(numColumns).fill(gap);
        layoutData = [];

        // Calculate layout for all items (but don't create DOM elements yet)
        mediaData.forEach((media, index) => {
          const aspectRatio =
            media.size.height > 0 ? media.size.width / media.size.height : 1;
          const itemHeight = colWidth / aspectRatio;

          let shortestColIndex = 0;
          for (let i = 1; i < numColumns; i++) {
            if (colHeights[i] < colHeights[shortestColIndex]) {
              shortestColIndex = i;
            }
          }

          const top = colHeights[shortestColIndex];
          const left = gap + shortestColIndex * (colWidth + gap);

          layoutData[index] = {
            x: left,
            y: top,
            width: colWidth,
            height: itemHeight,
            col: shortestColIndex,
          };
          colHeights[shortestColIndex] += itemHeight + gap;
        });

        const totalHeight = Math.max(...colHeights);
        grid.style.height = totalHeight + "px";

        // Now update which items should be rendered
        updateVirtualItems();
      }

      // ========== Keyboard Navigation ==========

      document.addEventListener("keydown", function (e) {
        // Check if goto modal is open
        const gotoModal = document.getElementById("gotoModal");
        const isGotoModalOpen = gotoModal.classList.contains("visible");

        if (isGotoModalOpen) {
          // Let the input handle its own keyboard events (Enter/Escape handled in setupGotoModal)
          return;
        }

        // Check if folder filter modal is open
        const folderModal = document.getElementById("folderFilterModal");
        const isFolderModalOpen = folderModal.classList.contains("visible");

        if (isFolderModalOpen) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeFolderFilterModal();
            return;
          }
          // Don't process other keys when modal is open
          return;
        }

        // Don't intercept when focused on form controls
        const activeEl = document.activeElement;
        const isFormControl =
          activeEl &&
          (activeEl.tagName === "INPUT" ||
            activeEl.tagName === "SELECT" ||
            activeEl.tagName === "TEXTAREA");
        if (isFormControl) return;

        // Don't process if no media loaded
        if (mediaData.length === 0) return;

        if (isFullscreen) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          if (e.key === " ") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          if (e.key === "x" || e.key === "X") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          // Video seek controls (Q = rewind, E = forward)
          // Seek time: 1s if <5s duration, 3s if <15s, otherwise 15s
          if (e.key === "q" || e.key === "Q") {
            e.preventDefault();
            const video = document.querySelector("#fullscreen-media video");
            if (video) {
              const seekTime = video.duration < 10 ? 1 : video.duration < 45 ? 3 : 15;
              video.currentTime = Math.max(0, video.currentTime - seekTime);
            }
            return;
          }
          if (e.key === "e" || e.key === "E") {
            e.preventDefault();
            const video = document.querySelector("#fullscreen-media video");
            if (video) {
              const seekTime = video.duration < 10 ? 1 : video.duration < 45 ? 3 : 15;
              video.currentTime = Math.min(
                video.duration || 0,
                video.currentTime + seekTime,
              );
            }
            return;
          }
          if (e.key === "m" || e.key === "M") {
            e.preventDefault();
            const video = document.querySelector("#fullscreen-media video");
            if (video) {
              video.muted = !video.muted;
            }
            return;
          }
          // Allow navigation in fullscreen mode
          let nextIndex = currentIndex;
          switch (e.key) {
            case "ArrowLeft":
            case "a":
            case "A":
              e.preventDefault();
              nextIndex = findNearest("left");
              break;
            case "ArrowRight":
            case "d":
            case "D":
              e.preventDefault();
              nextIndex = findNearest("right");
              break;
            case "ArrowUp":
            case "w":
            case "W":
              e.preventDefault();
              nextIndex = findNearest("up");
              break;
            case "ArrowDown":
            case "s":
            case "S":
              e.preventDefault();
              nextIndex = findNearest("down");
              break;
            case "c":
            case "C":
              e.preventDefault();
              scrollToCurrent();
              return;
            case "i":
            case "I":
              e.preventDefault();
              showFileInfo = !showFileInfo;
              updateFileInfo();
              return;
            default:
              return;
          }
          currentIndex = nextIndex;
          updateSelection();
          updateScrollIndicator();
          scrollToCurrent(); // Scroll background in fullscreen mode
          updateFullscreenContent();
          updateFileInfo();
          return;
        }

        let nextIndex = currentIndex;
        switch (e.key) {
          case "ArrowLeft":
          case "a":
          case "A":
            e.preventDefault();
            nextIndex = findNearest("left");
            break;
          case "ArrowRight":
          case "d":
          case "D":
            e.preventDefault();
            nextIndex = findNearest("right");
            break;
          case "ArrowUp":
          case "w":
          case "W":
            e.preventDefault();
            nextIndex = findNearest("up");
            break;
          case "ArrowDown":
          case "s":
          case "S":
            e.preventDefault();
            nextIndex = findNearest("down");
            break;
          case " ":
            e.preventDefault();
            openFullscreen();
            return;
          case "x":
          case "X":
            e.preventDefault();
            openFullscreen();
            return;
          case "q":
          case "Q":
            e.preventDefault();
            // Seek currently selected video backward (adaptive time)
            {
              const element = renderedItems.get(currentIndex);
              if (element && element.dataset.type === "video") {
                const video = element.querySelector("video");
                if (video) {
                  const seekTime = video.duration < 10 ? 1 : video.duration < 45 ? 3 : 15;
                  video.currentTime = Math.max(0, video.currentTime - seekTime);
                }
              }
            }
            return;
          case "e":
          case "E":
            e.preventDefault();
            // Seek currently selected video forward (adaptive time)
            {
              const element = renderedItems.get(currentIndex);
              if (element && element.dataset.type === "video") {
                const video = element.querySelector("video");
                if (video) {
                  const seekTime = video.duration < 10 ? 1 : video.duration < 45 ? 3 : 15;
                  video.currentTime = Math.min(
                    video.duration || 0,
                    video.currentTime + seekTime,
                  );
                }
              }
            }
            return;
          case "c":
          case "C":
            e.preventDefault();
            // Scroll back to currently selected item
            scrollToCurrent();
            return;
          case "m":
          case "M":
            e.preventDefault();
            // Toggle mute on currently selected video
            {
              const element = renderedItems.get(currentIndex);
              if (element && element.dataset.type === "video") {
                const video = element.querySelector("video");
                if (video) {
                  video.muted = !video.muted;
                }
              }
            }
            return;
          case "i":
          case "I":
            e.preventDefault();
            showFileInfo = !showFileInfo;
            updateFileInfo();
            return;
          case "f":
          case "F":
            e.preventDefault();
            openFolderFilterModal();
            return;
          case "g":
          case "G":
            e.preventDefault();
            openGotoModal();
            return;
          case "z":
          case "Z":
            e.preventDefault();
            goToPreviousFolder();
            return;
          case "v":
          case "V":
            e.preventDefault();
            goToNextFolder();
            return;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            // Don't intercept Cmd+number (tab switching) or Ctrl+number
            if (e.metaKey || e.ctrlKey) return;
            e.preventDefault();
            {
              const percentage = parseInt(e.key) * 10;
              const scrollHeight =
                document.documentElement.scrollHeight - window.innerHeight;
              const targetScroll = (scrollHeight * percentage) / 100;
              window.scrollTo(0, targetScroll);
            }
            return;
          default:
            return;
        }

        currentIndex = nextIndex;
        updateSelection();
        updateScrollIndicator();
        scrollToCurrent();
        updateFileInfo();
      });

      function findNearest(direction) {
        if (layoutData.length === 0 || !layoutData[currentIndex]) {
          return currentIndex;
        }

        const current = layoutData[currentIndex];
        const currentCenterX = current.x + current.width / 2;
        const currentCenterY = current.y + current.height / 2;

        let bestIndex = currentIndex;
        let minScore = Infinity;

        // Find nearest item in the given direction
        for (let i = 0; i < layoutData.length; i++) {
          const p = layoutData[i];
          const centerX = p.x + p.width / 2;
          const centerY = p.y + p.height / 2;

          // Filter by direction
          let isCandidate = false;
          switch (direction) {
            case "up":
              isCandidate = centerY < currentCenterY;
              break;
            case "down":
              isCandidate = centerY > currentCenterY;
              break;
            case "left":
              isCandidate = centerX < currentCenterX;
              break;
            case "right":
              isCandidate = centerX > currentCenterX;
              break;
          }

          if (!isCandidate) continue;

          // Calculate distance with direction weighting
          const dx = centerX - currentCenterX;
          const dy = centerY - currentCenterY;
          const score =
            direction === "up" || direction === "down"
              ? Math.sqrt(dx * dx * 4 + dy * dy)
              : Math.sqrt(dx * dx + dy * dy * 4);

          if (score < minScore) {
            minScore = score;
            bestIndex = i;
          }
        }

        return bestIndex;
      }

      // ========== Selection & UI Updates ==========

      function updateSelection() {
        // Remove selection from previous element if it changed
        if (previousIndex !== currentIndex) {
          const prevElement = renderedItems.get(previousIndex);
          if (prevElement) {
            prevElement.classList.remove("selected");
          }
          previousIndex = currentIndex;
        }
        // Always ensure current element is selected (handles initial load and re-renders)
        const currElement = renderedItems.get(currentIndex);
        if (currElement && !currElement.classList.contains("selected")) {
          currElement.classList.add("selected");
        }
      }
      function updateScrollIndicator() {
        document.getElementById("currentIndex").textContent = currentIndex + 1;
        document.getElementById("totalCount").textContent = mediaData.length;
      }
      function scrollToCurrent(smooth = true) {
        const layout = layoutData[currentIndex];
        if (layout) {
          // Scroll to the calculated position
          const targetY = layout.y + layout.height / 2 - window.innerHeight / 2;
          const currentY = window.scrollY;
          const distance = Math.abs(targetY - currentY);
          
          // Use instant scroll if distance is more than 1.5 viewport heights
          const useSmooth = smooth && distance < window.innerHeight * 1.5;
          
          if (useSmooth) {
            window.scrollTo({
              top: Math.max(0, targetY),
              behavior: "smooth",
            });
            // After smooth scroll, ensure the item is rendered and selected
            setTimeout(() => {
              updateVirtualItems();
              updateSelection();
            }, 100);
          } else {
            window.scrollTo(0, Math.max(0, targetY));
            updateVirtualItems();
            // Give DOM a moment to render the new elements
            setTimeout(() => {
              updateSelection();
            }, 10);
          }
        }
      }
      // ========== Fullscreen Mode ==========

      function openFullscreen() {
        if (!mediaData[currentIndex]) return;

        // Ensure the current item is loaded for fullscreen
        if (!loadedItems.has(currentIndex)) {
          // If not rendered, we need to ensure it exists first
          if (!renderedItems.has(currentIndex)) {
            // Scroll to it first to make sure it gets rendered
            scrollToCurrent(false); // Instant scroll when opening fullscreen
            setTimeout(() => {
              if (
                renderedItems.has(currentIndex) &&
                !loadedItems.has(currentIndex)
              ) {
                loadMediaItem(currentIndex);
              }
              updateFullscreenContent();
              document.getElementById("fullscreen").classList.add("active");
              isFullscreen = true;
              updateFileInfo();
            }, 200);
            return;
          }
          loadMediaItem(currentIndex);
        }

        updateFullscreenContent();
        document.getElementById("fullscreen").classList.add("active");
        isFullscreen = true;
        updateFileInfo();
      }
      function updateFileInfo() {
        const itemData = mediaData[currentIndex];
        if (!itemData) return;

        document.getElementById("infoFilename").textContent = itemData.name;
        document.getElementById("infoDimensions").textContent =
          itemData.size.width > 0 && itemData.size.height > 0
            ? `${itemData.size.width} Ã— ${itemData.size.height}`
            : "Unknown";
        document.getElementById("infoType").textContent =
          itemData.type === "video" ? "Video" : "Image";

        // Update the file link
        const fileLink = document.getElementById("infoFileLink");
        const fileSrc = baseDirectory + "/" + itemData.name;
        fileLink.href = fileSrc;

        // Show/hide based on toggle state (works both in and out of fullscreen)
        const overlay = document.getElementById("fileInfoOverlay");
        if (showFileInfo) {
          overlay.classList.add("visible");
        } else {
          overlay.classList.remove("visible");
        }
      }

      function updateFullscreenContent() {
        const itemData = mediaData[currentIndex];
        if (!itemData) return;

        // Ensure the current item is loaded for fullscreen
        if (!loadedItems.has(currentIndex)) {
          if (renderedItems.has(currentIndex)) {
            loadMediaItem(currentIndex);
          }
        }

        const fullscreenMedia = document.getElementById("fullscreen-media");
        const type = itemData.type;
        const src = baseDirectory + "/" + itemData.name;
        const mimeType = itemData.mimeType;
        if (type === "image") {
          fullscreenMedia.innerHTML = `<img src="${src}" alt="Image ${
            currentIndex + 1
          }">`;
        } else {
          const savedTime = videoTimes.get(currentIndex) || 0;
          fullscreenMedia.innerHTML = `<video autoplay loop controls><source src="${src}" type="${mimeType}"></video>`;
          // Wait for video to load, then resume from saved time
          setTimeout(() => {
            const video = fullscreenMedia.querySelector("video");
            if (video) {
              video.addEventListener(
                "loadedmetadata",
                () => {
                  video.currentTime = Math.min(savedTime, video.duration || 0);
                },
                { once: true },
              );
            }
          }, 0);
        }
        updateFileInfo();
      }
      function closeFullscreen() {
        document.getElementById("fullscreen").classList.remove("active");
        isFullscreen = false;
        document.getElementById("fullscreen-media").innerHTML = "";
      }

      document
        .getElementById("fullscreen")
        .addEventListener("click", function (e) {
          if (e.target === this) closeFullscreen();
        });

      // ========== Auto-scroll ==========

      function startAutoScroll() {
        stopAutoScroll();
        autoScrollTimer = setInterval(() => {
          window.scrollBy(0, Number(autoScrollSpeed.value));
        }, 50);
      }

      function stopAutoScroll() {
        if (autoScrollTimer) {
          clearInterval(autoScrollTimer);
          autoScrollTimer = null;
        }
      }

      // ========== Initialization ==========

      document.addEventListener("DOMContentLoaded", function () {
        setupDropZone();
        setupShortcutsMenu();
        setupFolderFilterModal();
        setupGotoModal();
        setupCopyButton();
      });

      function setupCopyButton() {
        const copyBtn = document.getElementById("infoCopyBtn");
        copyBtn.addEventListener("click", async () => {
          const filename = document.getElementById("infoFilename").textContent;
          try {
            await navigator.clipboard.writeText(filename);
            copyBtn.textContent = "[copied!]";
            setTimeout(() => {
              copyBtn.textContent = "[copy]";
            }, 1000);
          } catch (err) {
            console.error("Failed to copy:", err);
          }
        });
      }

      function setupShortcutsMenu() {
        const shortcutsToggle = document.getElementById("shortcuts-toggle");
        const shortcutsList = document.getElementById("shortcuts-list");
        const shortcutsContainer = document.querySelector(
          ".shortcuts-container",
        );

        shortcutsToggle.addEventListener("click", (e) => {
          e.stopPropagation();
          shortcutsList.classList.toggle("visible");
        });

        document.addEventListener("click", (e) => {
          if (!shortcutsContainer.contains(e.target)) {
            shortcutsList.classList.remove("visible");
          }
        });
      }

      function setupFolderFilterModal() {
        const folderModal = document.getElementById("folderFilterModal");

        // Click outside to close
        folderModal.addEventListener("click", (e) => {
          if (e.target === folderModal) closeFolderFilterModal();
        });

        // Enable all folders
        document
          .getElementById("enableAllFolders")
          .addEventListener("click", () => {
            allFolders.forEach((folder, index) => {
              enabledFolders.add(folder);
              const checkbox = document.querySelector(
                `input[data-folder-index="${index}"]`,
              );
              if (checkbox) checkbox.checked = true;
            });
            applyFilters();
          });

        // Disable all folders
        document
          .getElementById("disableAllFolders")
          .addEventListener("click", () => {
            allFolders.forEach((folder, index) => {
              enabledFolders.delete(folder);
              const checkbox = document.querySelector(
                `input[data-folder-index="${index}"]`,
              );
              if (checkbox) checkbox.checked = false;
            });
            applyFilters();
          });

        // Enable only current folder
        document
          .getElementById("enableOnlyCurrentFolder")
          .addEventListener("click", () => {
            const currentFolder = mediaData[currentIndex]
              ? getFolderFromItem(mediaData[currentIndex])
              : null;

            if (currentFolder !== null) {
              enabledFolders.clear();
              allFolders.forEach((folder, index) => {
                const checkbox = document.querySelector(
                  `input[data-folder-index="${index}"]`,
                );
                if (checkbox) checkbox.checked = false;
              });

              enabledFolders.add(currentFolder);
              const currentFolderIndex = allFolders.indexOf(currentFolder);
              if (currentFolderIndex !== -1) {
                const checkbox = document.querySelector(
                  `input[data-folder-index="${currentFolderIndex}"]`,
                );
                if (checkbox) checkbox.checked = true;
              }

              applyFilters();
            }
          });
      }

      function setupGotoModal() {
        const gotoModal = document.getElementById("gotoModal");
        const gotoInput = document.getElementById("gotoInput");

        // Click outside to close
        gotoModal.addEventListener("click", (e) => {
          if (e.target === gotoModal) closeGotoModal();
        });

        // Handle Enter key to go to item
        gotoInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            gotoItemByNumberOrName(gotoInput.value);
          } else if (e.key === "Escape") {
            e.preventDefault();
            closeGotoModal();
          }
        });
      }
    </script>
  </body>
</html>
