<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grid Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #0a0a0a;
        color: #fff;
        overflow-x: hidden;
        user-select: none;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        padding: 0.5rem 1rem;
        z-index: 1600;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        font-size: 0.9rem;
        opacity: 0.8;
      }

      .controls select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .controls select:focus {
        outline: none;
        border-color: #ff6b6b;
      }

      #zoom-slider {
        vertical-align: middle;
      }

      .shortcuts-container {
        position: relative;
      }

      .shortcuts-toggle {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s;
      }

      .shortcuts-toggle:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .shortcuts-list {
        display: none;
        position: absolute;
        top: calc(100% + 0.5rem);
        right: 0;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 1rem;
        min-width: 250px;
        z-index: 2000;
        flex-direction: column;
        gap: 0.75rem;
      }

      .shortcuts-list.visible {
        display: flex;
      }

      .shortcuts-list span {
        white-space: nowrap;
        opacity: 0.9;
      }

      .drop-zone {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.95);
        z-index: 1500;
        transition: opacity 0.3s ease;
      }

      .drop-zone.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .drop-zone.drag-over {
        background: rgba(255, 107, 107, 0.1);
        border: 2px dashed #ff6b6b;
      }

      .drop-zone h2 {
        font-size: 2rem;
        margin-bottom: 1rem;
        color: #fff;
      }

      .drop-zone p {
        font-size: 1.1rem;
        color: #ccc;
        text-align: center;
        max-width: 500px;
      }

      :root {
        --item-width: 18vw;
        --gap: 8px;
      }
      .masonry-grid {
        margin-top: 60px;
        position: relative;
      }
      .media-item {
        position: absolute;
        border: none;
        border-radius: 0;
        overflow: hidden;
        cursor: pointer;
        background: #1a1a1a;
        transition: box-shadow 0.2s, top 0.3s ease, left 0.3s ease,
          width 0.3s ease;
      }
      .media-item.selected {
        outline: 3px solid #ff6b6b;
        z-index: 10;
      }
      .media-item img,
      .media-item video {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }
      .media-item video {
        background: #000;
      }
      .media-placeholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
      }
      .media-item.loaded .media-placeholder {
        display: none;
        opacity: 0;
        pointer-events: none;
      }
      .media-item.virtualized {
        background: #1a1a1a;
      }
      .media-item.virtualized .media-placeholder {
        background: #1a1a1a;
        color: #333;
      }
      .fullscreen-overlay {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 2000;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .fullscreen-overlay.active {
        opacity: 1;
        pointer-events: all;
      }
      .fullscreen-content {
        max-width: 100vw;
        max-height: 100vh;
        position: relative;
      }
      .fullscreen-content img,
      .fullscreen-content video {
        max-width: 100vw;
        max-height: 100vh;
        object-fit: contain;
      }
      .scroll-indicator {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.9rem;
        z-index: 1000;
      }
      .file-info-overlay {
        position: fixed;
        bottom: 2rem;
        left: 2rem;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        font-size: 0.9rem;
        z-index: 2100;
        max-width: 400px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .file-info-overlay.visible {
        opacity: 1;
        pointer-events: all;
      }
      .file-info-overlay .info-line {
        margin: 0.25rem 0;
      }
      .file-info-overlay .info-label {
        opacity: 0.7;
        margin-right: 0.5rem;
      }
      .file-info-overlay a {
        color: #ff6b6b;
        text-decoration: none;
        transition: opacity 0.2s;
      }
      .file-info-overlay a:hover {
        opacity: 0.8;
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1 id="title">Grid Viewer</h1>
      <div class="controls">
        <span
          >Zoom:
          <input
            type="range"
            id="zoom-slider"
            min="6"
            max="40"
            value="18"
            step="2"
        /></span>
        <span
          >Auto-scroll speed:
          <input
            type="range"
            id="auto-scroll-speed"
            min="0"
            max="200"
            value="0"
            step="10"
        /></span>
        <span
          >Sort:
          <select id="sort-order">
            <option value="filename-asc">Filename A-Z</option>
            <option value="filename-desc">Filename Z-A</option>
            <option value="mtime-newest">Newest First</option>
            <option value="mtime-oldest">Oldest First</option>
            <option value="mtime-newest-grouped">Newest First (Grouped)</option>
            <option value="random">Random</option>
            <option value="random-grouped">Random (Grouped)</option>
          </select></span
        >
        <div class="shortcuts-container">
          <button class="shortcuts-toggle" id="shortcuts-toggle">Shortcuts</button>
          <div class="shortcuts-list" id="shortcuts-list">
            <span>Arrows/WASD to navigate</span>
            <span>Space/X to maximize</span>
            <span>Q/E ±15s video</span>
            <span>M to mute/unmute video</span>
            <span>C to center on selected</span>
            <span>I for info</span>
            <span>ESC to close</span>
          </div>
        </div>
      </div>
    </div>

    <div class="drop-zone" id="dropZone">
      <h2>Drop a PGrid File</h2>
      <p>
        Drag and drop a <code>_pgrid.jpg</code> file generated by grid.ts to
        view the media collection
      </p>
    </div>

    <div class="masonry-grid" id="grid"></div>

    <div class="fullscreen-overlay" id="fullscreen">
      <div class="fullscreen-content" id="fullscreen-media"></div>
    </div>

    <div class="scroll-indicator" id="scrollIndicator">
      <span id="currentIndex">0</span> / <span id="totalCount">0</span>
    </div>

    <div class="file-info-overlay" id="fileInfoOverlay">
      <div class="info-line">
        <span class="info-label">File:</span>
        <span id="infoFilename">-</span>
        <a id="infoFileLink" href="#" target="_blank" style="margin-left: 0.5rem;">[open]</a>
      </div>
      <div class="info-line">
        <span class="info-label">Dimensions:</span>
        <span id="infoDimensions">-</span>
      </div>
      <div class="info-line">
        <span class="info-label">Type:</span>
        <span id="infoType">-</span>
      </div>
    </div>

    <script>
      let autoScrollTimer = null;
      let currentIndex = 0;
      let items = [];
      let isFullscreen = false;
      let layoutData = [];
      let loadedItems = new Set();
      let observer;
      let loadDebounceTimer = null;
      let visibleItems = new Set();
      let autoScrollSpeed;
      let mediaData = [];
      let baseDirectory = "";
      let currentSortOrder = "filename-asc";
      let globalListenersInitialized = false;
      let videoTimes = new Map(); // Track video playback times
      let showFileInfo = false;

      function setupDropZone() {
        const dropZone = document.getElementById("dropZone");

        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        ["dragenter", "dragover"].forEach((eventName) => {
          dropZone.addEventListener(eventName, highlight, false);
        });

        ["dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
          dropZone.classList.add("drag-over");
        }

        function unhighlight(e) {
          dropZone.classList.remove("drag-over");
        }

        dropZone.addEventListener("drop", handleDrop, false);

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;

          if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith("_pgrid.jpg")) {
              processPgridFile(file);
            } else {
              alert("Please drop a _pgrid.jpg file");
            }
          }
        }

        // Allow dropping a new file anywhere on the page
        // Show drop zone when dragging over the document
        document.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dropZone.classList.remove("hidden");
        });

        document.addEventListener("dragover", (e) => {
          e.preventDefault();
        });

        document.addEventListener("dragleave", (e) => {
          e.preventDefault();
          // Only hide when actually leaving the document (relatedTarget is null)
          if (e.relatedTarget === null && mediaData.length > 0) {
            dropZone.classList.add("hidden");
          }
        });

        document.addEventListener("drop", (e) => {
          e.preventDefault();
          // Hide drop zone if we have media loaded (will show again if new file is processed)
          if (mediaData.length > 0) {
            dropZone.classList.add("hidden");
          }
        });
      }

      async function processPgridFile(file) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          // Convert to string to search for our metadata marker
          const fileText = new TextDecoder().decode(uint8Array);

          // Look for our metadata marker
          const startMarker = "<!--PGGRID_METADATA:";
          const endMarker = "-->";

          const startIndex = fileText.lastIndexOf(startMarker);
          if (startIndex === -1) {
            alert("Could not find metadata in the pgrid file");
            return;
          }

          const endIndex = fileText.indexOf(endMarker, startIndex);
          if (endIndex === -1) {
            alert("Invalid metadata format in the pgrid file");
            return;
          }

          // Extract the JSON data between markers
          const jsonStart = startIndex + startMarker.length;
          const jsonText = fileText.substring(jsonStart, endIndex);

          let cacheData;
          try {
            cacheData = JSON.parse(jsonText);
          } catch {
            alert("Invalid JSON metadata in the pgrid file");
            return;
          }

          initializeViewer(cacheData, file.name);
        } catch (e) {
          console.error("Error processing pgrid file:", e);
          alert("Error processing the pgrid file");
        }
      }

      function initializeViewer(cacheData, filename) {
        // Reset state from any previous file
        if (observer) {
          observer.disconnect();
        }
        loadedItems.clear();
        visibleItems.clear();
        videoTimes.clear();
        currentIndex = 0;
        layoutData = [];
        if (loadDebounceTimer) {
          clearTimeout(loadDebounceTimer);
          loadDebounceTimer = null;
        }
        stopAutoScroll();

        // Extract directory name from filename (remove _pgrid.jpg)
        const dirName = filename.replace("_pgrid.jpg", "");
        baseDirectory = dirName;

        // Convert cache data to media items
        mediaData = Object.entries(cacheData).map(([name, data]) => {
          const mimeType = getMimeType(name);
          const type = mimeType.startsWith("video/") ? "video" : "image";
          return {
            name,
            size: data.size,
            mimeType,
            type,
            mtime: data.mtime || 0,
          };
        });

        // Apply currently selected sort order from dropdown
        const sortOrder = document.getElementById("sort-order").value;
        currentSortOrder = sortOrder;
        applySortOrder(sortOrder);

        // Hide drop zone
        document.getElementById("dropZone").classList.add("hidden");

        // Update title (both header and browser tab)
        document.getElementById("title").textContent = dirName;
        document.title = dirName;

        // Generate HTML for media items
        generateMediaItems();

        // Scroll to top when loading new file
        window.scrollTo(0, 0);

        // Initialize the viewer
        initializeViewerComponents();
      }

      const MIME_TYPES = {
        // Video formats
        mp4: "video/mp4",
        avi: "video/x-msvideo",
        mov: "video/quicktime",
        mkv: "video/x-matroska",
        webm: "video/webm",
        flv: "video/x-flv",
        wmv: "video/x-ms-wmv",
        m4v: "video/x-m4v",
        "3gp": "video/3gpp",
        "3g2": "video/3gpp2",
        ogv: "video/ogg",
        ts: "video/mp2t",
        mts: "video/mp2t",
        m2ts: "video/mp2t",
        vob: "video/mpeg",
        asf: "video/x-ms-asf",
        divx: "video/x-msvideo",
        xvid: "video/x-msvideo",
        f4v: "video/x-f4v",
        mpg: "video/mpeg",
        mpeg: "video/mpeg",
        mpe: "video/mpeg",
        m1v: "video/mpeg",
        m2v: "video/mpeg",
        mpv: "video/mp4",
        mpv2: "video/mp4",
        m4s: "video/mp4",
        m4b: "audio/mp4",
        m4a: "audio/mp4",
        m4p: "audio/mp4",
        m4r: "audio/mp4",
        // Image formats
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        png: "image/png",
        gif: "image/gif",
        bmp: "image/bmp",
        webp: "image/webp",
        svg: "image/svg+xml",
        ico: "image/x-icon",
        tiff: "image/tiff",
        tif: "image/tiff",
        jxl: "image/jxl",
        jp2: "image/jp2",
        jpx: "image/jpx",
        jpm: "image/jpm",
        jpf: "image/jpx",
        heic: "image/heic",
        heif: "image/heif",
        avif: "image/avif",
      };

      function getMimeType(filename) {
        const ext = filename.toLowerCase().split(".").pop();
        return MIME_TYPES[ext] || "application/octet-stream";
      }

      function applySortOrder(sortOrder) {
        switch (sortOrder) {
          case "filename-asc":
            mediaData.sort((a, b) => a.name.localeCompare(b.name));
            break;
          case "filename-desc":
            mediaData.sort((a, b) => b.name.localeCompare(a.name));
            break;
          case "mtime-newest":
            // Sort by modified time (newest first)
            mediaData.sort((a, b) => {
              const timeA = a.mtime || 0;
              const timeB = b.mtime || 0;
              return timeB - timeA;
            });
            break;
          case "mtime-oldest":
            // Sort by modified time (oldest first)
            mediaData.sort((a, b) => {
              const timeA = a.mtime || 0;
              const timeB = b.mtime || 0;
              return timeA - timeB;
            });
            break;
          case "mtime-newest-grouped":
            // Group by folder, sort folders by newest file, then interleave files
            const folderGroupsNewest = new Map();

            // Group items by folder (everything before the last '/')
            mediaData.forEach((item) => {
              const lastSlash = item.name.lastIndexOf("/");
              const folder =
                lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
              if (!folderGroupsNewest.has(folder)) {
                folderGroupsNewest.set(folder, []);
              }
              folderGroupsNewest.get(folder).push(item);
            });

            // Sort items within each folder by mtime (newest first)
            folderGroupsNewest.forEach((items) => {
              items.sort((a, b) => {
                const timeA = a.mtime || 0;
                const timeB = b.mtime || 0;
                return timeB - timeA;
              });
            });

            // Sort folders by their newest file's mtime
            const foldersNewest = Array.from(folderGroupsNewest.keys()).sort(
              (a, b) => {
                const newestA = folderGroupsNewest.get(a)[0]?.mtime || 0;
                const newestB = folderGroupsNewest.get(b)[0]?.mtime || 0;
                return newestB - newestA;
              }
            );

            // Interleave files: take file 0 from each folder, then file 1, etc.
            mediaData = [];
            const folderArrays = foldersNewest.map((folder) =>
              folderGroupsNewest.get(folder)
            );
            const maxLength = Math.max(
              ...folderArrays.map((arr) => arr.length)
            );

            for (let i = 0; i < maxLength; i++) {
              folderArrays.forEach((items) => {
                if (i < items.length) {
                  mediaData.push(items[i]);
                }
              });
            }
            break;
          case "random":
            // Fisher-Yates shuffle
            for (let i = mediaData.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [mediaData[i], mediaData[j]] = [mediaData[j], mediaData[i]];
            }
            break;
          case "random-grouped":
            // Group by folder, randomize groups, then randomize within each group
            const folderGroups = new Map();

            // Group items by folder (everything before the last '/')
            mediaData.forEach((item) => {
              const lastSlash = item.name.lastIndexOf("/");
              const folder =
                lastSlash >= 0 ? item.name.substring(0, lastSlash) : "";
              if (!folderGroups.has(folder)) {
                folderGroups.set(folder, []);
              }
              folderGroups.get(folder).push(item);
            });

            // Convert to array and shuffle the folders
            const folders = Array.from(folderGroups.keys());
            for (let i = folders.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [folders[i], folders[j]] = [folders[j], folders[i]];
            }

            // Shuffle items within each folder and rebuild mediaData
            mediaData = [];
            folders.forEach((folder) => {
              const items = folderGroups.get(folder);
              // Fisher-Yates shuffle within the folder
              for (let i = items.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [items[i], items[j]] = [items[j], items[i]];
              }
              mediaData.push(...items);
            });
            break;
        }
      }

      function sortMediaItems() {
        const sortOrder = document.getElementById("sort-order").value;
        currentSortOrder = sortOrder;

        applySortOrder(sortOrder);

        // Regenerate the grid with new order
        generateMediaItems();

        // Re-initialize items array and recalculate layout
        items = Array.from(document.querySelectorAll(".media-item"));
        calculateLayout();

        // Reset current index to 0 when sorting changes
        currentIndex = 0;
        updateSelection();
        updateScrollIndicator();

        // Re-setup virtualization
        if (observer) {
          observer.disconnect();
        }
        setupVirtualization();

        // Force check for visible items after layout changes
        setTimeout(() => {
          // Clear any existing loaded items since order changed
          loadedItems.clear();
          visibleItems.clear();

          // Force intersection observer to check all items
          items.forEach((item) => {
            observer.unobserve(item);
            observer.observe(item);
          });

          // Manually trigger loading for items that should be visible
          const visibleItemsArray = Array.from(visibleItems);
          visibleItemsArray.forEach((index) => {
            if (!loadedItems.has(index)) {
              loadMediaItem(index);
            }
          });
        }, 100);

        // Re-attach click and double-click events
        items.forEach((item, index) => {
          item.addEventListener("click", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            scrollToCurrent();
            updateFileInfo();
          });

          item.addEventListener("dblclick", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            openFullscreen();
          });
        });
      }

      function generateMediaItems() {
        const grid = document.getElementById("grid");
        const itemsHTML = mediaData
          .map((item, index) => {
            let aspectStyle = "";
            if (item.size.width > 0 && item.size.height > 0) {
              aspectStyle = `style="aspect-ratio: ${item.size.width} / ${item.size.height};"`;
            }
            // Compose src using baseDirectory and item.name
            const src = baseDirectory + "/" + item.name;
            return `<div class="media-item virtualized" data-index="${index}" data-type="${item.type}" data-name="${item.name}" data-src="${src}" data-mime-type="${item.mimeType}" ${aspectStyle}>
                        <div class="media-placeholder">
                            Virtualized
                        </div>
                    </div>`;
          })
          .join("");

        grid.innerHTML = itemsHTML;
      }

      function initializeViewerComponents() {
        items = Array.from(document.querySelectorAll(".media-item"));

        // Apply pre-set zoom value
        const zoomSlider = document.getElementById("zoom-slider");
        const width = zoomSlider.value + "vw";
        document.documentElement.style.setProperty("--item-width", width);

        calculateLayout();
        updateSelection();
        updateScrollIndicator();
        updateFileInfo();
        setupVirtualization();

        // Apply pre-set auto-scroll speed
        const speed = Number(
          document.getElementById("auto-scroll-speed").value
        );
        if (speed > 0) {
          stopAutoScroll();
          startAutoScroll();
        }

        // Click to select items (these are new elements each time, so always add)
        items.forEach((item, index) => {
          item.addEventListener("click", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            scrollToCurrent();
            updateFileInfo();
          });
        });

        // Double-click to open fullscreen (these are new elements each time, so always add)
        items.forEach((item, index) => {
          item.addEventListener("dblclick", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            openFullscreen();
          });
        });

        // Only add global listeners once
        if (!globalListenersInitialized) {
          globalListenersInitialized = true;

          window.addEventListener("resize", calculateLayout);

          // Zoom slider: adjust CSS grid column width
          const zoomSlider = document.getElementById("zoom-slider");
          zoomSlider.addEventListener("input", (e) => {
            const width = e.target.value + "vw";
            document.documentElement.style.setProperty("--item-width", width);
            calculateLayout();
          });

          // Auto-scroll interval control (0 = off)
          autoScrollSpeed = document.getElementById("auto-scroll-speed");
          autoScrollSpeed.addEventListener("input", () => {
            const speed = Number(autoScrollSpeed.value);
            if (speed > 0) {
              stopAutoScroll();
              startAutoScroll();
            } else {
              stopAutoScroll();
            }
          });

          // Sort order dropdown
          const sortOrderSelect = document.getElementById("sort-order");
          sortOrderSelect.addEventListener("change", () => {
            sortMediaItems();
          });
        }
      }

      function setupVirtualization() {
        // Create intersection observer to load items when they become visible
        observer = new IntersectionObserver(
          (entries) => {
            // Track which items are currently intersecting
            entries.forEach((entry) => {
              const index = parseInt(entry.target.dataset.index);
              if (entry.isIntersecting) {
                visibleItems.add(index);
              } else {
                visibleItems.delete(index);
              }
            });
            // Clear any existing debounce timer
            if (loadDebounceTimer) {
              clearTimeout(loadDebounceTimer);
            }
            // Debounce loading until scrolling stops
            loadDebounceTimer = setTimeout(() => {
              visibleItems.forEach((index) => {
                if (!loadedItems.has(index)) {
                  loadMediaItem(index);
                }
              });
            }, 150); // 150ms debounce delay
          },
          {
            rootMargin: "300px", // Start loading 300px before item becomes visible
          }
        );
        // Observe all items
        items.forEach((item) => {
          observer.observe(item);
        });
      }

      function loadMediaItem(index) {
        if (loadedItems.has(index)) return;

        const item = items[index];
        const type = item.dataset.type;
        const src = item.dataset.src;

        // Update placeholder text to show loading state
        const placeholder = item.querySelector(".media-placeholder");
        placeholder.textContent = "Loading...";

        loadedItems.add(index);
        item.classList.remove("virtualized");

        if (type === "image") {
          const img = document.createElement("img");
          img.src = src;
          img.onload = () => {
            item.classList.add("loaded");
          };
          img.onerror = () => {
            item.querySelector(".media-placeholder").textContent =
              "Failed to load";
            item.classList.add("loaded");
          };
          item.appendChild(img);
        } else if (type === "video") {
          const video = document.createElement("video");
          video.src = src;
          video.muted = true;
          video.loop = true;
          video.playsInline = true;
          video.autoplay = true;
          // Track video playback time
          video.addEventListener("timeupdate", () => {
            if (!video.paused) {
              videoTimes.set(index, video.currentTime);
            }
          });
          video.onloadeddata = () => {
            item.classList.add("loaded");
          };
          video.onerror = () => {
            item.querySelector(".media-placeholder").textContent =
              "Failed to load";
            item.classList.add("loaded");
          };
          item.appendChild(video);
        }
      }

      function calculateLayout() {
        const grid = document.getElementById("grid");
        const gap = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue("--gap")
        );
        const itemWidthVW = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--item-width"
          )
        );
        const itemWidthPx = (itemWidthVW / 100) * window.innerWidth;

        const containerWidth = grid.clientWidth;
        const numColumns = Math.max(
          1,
          Math.round(containerWidth / itemWidthPx)
        );
        const colWidth = (containerWidth - (numColumns + 1) * gap) / numColumns;

        const colHeights = Array(numColumns).fill(gap);
        layoutData = [];

        mediaData.forEach((media, index) => {
          const item = items[index];
          const aspectRatio =
            media.size.height > 0 ? media.size.width / media.size.height : 1;
          const itemHeight = colWidth / aspectRatio;

          let shortestColIndex = 0;
          for (let i = 1; i < numColumns; i++) {
            if (colHeights[i] < colHeights[shortestColIndex]) {
              shortestColIndex = i;
            }
          }

          const top = colHeights[shortestColIndex];
          const left = gap + shortestColIndex * (colWidth + gap);

          item.style.left = left + "px";
          item.style.top = top + "px";
          item.style.width = colWidth + "px";
          item.style.height = itemHeight + "px";

          layoutData[index] = {
            x: left,
            y: top,
            width: colWidth,
            height: itemHeight,
            col: shortestColIndex,
          };
          colHeights[shortestColIndex] += itemHeight + gap;
        });

        const totalHeight = Math.max(...colHeights);
        grid.style.height = totalHeight + "px";
      }

      // Keyboard navigation
      document.addEventListener("keydown", function (e) {
        // Don't intercept when focused on form controls
        const activeEl = document.activeElement;
        const isFormControl =
          activeEl &&
          (activeEl.tagName === "INPUT" ||
            activeEl.tagName === "SELECT" ||
            activeEl.tagName === "TEXTAREA");
        if (isFormControl) return;

        // Don't process if no media loaded
        if (items.length === 0) return;

        if (isFullscreen) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          if (e.key === " ") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          if (e.key === "x" || e.key === "X") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          // Video seek controls (Q = rewind 15s, E = forward 15s)
          if (e.key === "q" || e.key === "Q") {
            e.preventDefault();
            const video = document.querySelector("#fullscreen-media video");
            if (video) {
              video.currentTime = Math.max(0, video.currentTime - 15);
            }
            return;
          }
          if (e.key === "e" || e.key === "E") {
            e.preventDefault();
            const video = document.querySelector("#fullscreen-media video");
            if (video) {
              video.currentTime = Math.min(video.duration || 0, video.currentTime + 15);
            }
            return;
          }
          if (e.key === "m" || e.key === "M") {
            e.preventDefault();
            const video = document.querySelector("#fullscreen-media video");
            if (video) {
              video.muted = !video.muted;
            }
            return;
          }
          // Allow navigation in fullscreen mode
          let nextIndex = currentIndex;
          switch (e.key) {
            case "ArrowLeft":
            case "a":
            case "A":
              e.preventDefault();
              nextIndex = findNearest("left");
              break;
            case "ArrowRight":
            case "d":
            case "D":
              e.preventDefault();
              nextIndex = findNearest("right");
              break;
            case "ArrowUp":
            case "w":
            case "W":
              e.preventDefault();
              nextIndex = findNearest("up");
              break;
            case "ArrowDown":
            case "s":
            case "S":
              e.preventDefault();
              nextIndex = findNearest("down");
              break;
            case "c":
            case "C":
              e.preventDefault();
              scrollToCurrent();
              return;
            case "i":
            case "I":
              e.preventDefault();
              showFileInfo = !showFileInfo;
              updateFileInfo();
              return;
            default:
              return;
          }
          currentIndex = nextIndex;
          updateSelection();
          updateScrollIndicator();
          updateFullscreenContent();
          updateFileInfo();
          return;
        }

        let nextIndex = currentIndex;
        switch (e.key) {
          case "ArrowLeft":
          case "a":
          case "A":
            e.preventDefault();
            nextIndex = findNearest("left");
            break;
          case "ArrowRight":
          case "d":
          case "D":
            e.preventDefault();
            nextIndex = findNearest("right");
            break;
          case "ArrowUp":
          case "w":
          case "W":
            e.preventDefault();
            nextIndex = findNearest("up");
            break;
          case "ArrowDown":
          case "s":
          case "S":
            e.preventDefault();
            nextIndex = findNearest("down");
            break;
          case " ":
            e.preventDefault();
            openFullscreen();
            return;
          case "x":
          case "X":
            e.preventDefault();
            openFullscreen();
            return;
          case "q":
          case "Q":
            e.preventDefault();
            // Seek currently selected video backward 15s
            if (items[currentIndex] && items[currentIndex].dataset.type === "video") {
              const video = items[currentIndex].querySelector("video");
              if (video) {
                video.currentTime = Math.max(0, video.currentTime - 15);
              }
            }
            return;
          case "e":
          case "E":
            e.preventDefault();
            // Seek currently selected video forward 15s
            if (items[currentIndex] && items[currentIndex].dataset.type === "video") {
              const video = items[currentIndex].querySelector("video");
              if (video) {
                video.currentTime = Math.min(video.duration || 0, video.currentTime + 15);
              }
            }
            return;
          case "c":
          case "C":
            e.preventDefault();
            // Scroll back to currently selected item
            scrollToCurrent();
            return;
          case "m":
          case "M":
            e.preventDefault();
            // Toggle mute on currently selected video
            if (items[currentIndex] && items[currentIndex].dataset.type === "video") {
              const video = items[currentIndex].querySelector("video");
              if (video) {
                video.muted = !video.muted;
              }
            }
            return;
          case "i":
          case "I":
            e.preventDefault();
            showFileInfo = !showFileInfo;
            updateFileInfo();
            return;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            // Don't intercept Cmd+number (tab switching) or Ctrl+number
            if (e.metaKey || e.ctrlKey) return;
            e.preventDefault();
            {
              const percentage = parseInt(e.key) * 10;
              const scrollHeight =
                document.documentElement.scrollHeight - window.innerHeight;
              const targetScroll = (scrollHeight * percentage) / 100;
              window.scrollTo({
                top: targetScroll,
                behavior: "smooth",
              });
            }
            return;
          default:
            return;
        }
        currentIndex = nextIndex;
        updateSelection();
        updateScrollIndicator();
        scrollToCurrent();
        updateFileInfo();
      });

      function findNearest(direction) {
        if (layoutData.length === 0 || !layoutData[currentIndex])
          return currentIndex;

        const current = { ...layoutData[currentIndex], index: currentIndex };
        const currentCenter = {
          x: current.x + current.width / 2,
          y: current.y + current.height / 2,
        };

        const candidates = layoutData
          .map((p, i) => ({ ...p, index: i }))
          .filter((p) => {
            const center = { x: p.x + p.width / 2, y: p.y + p.height / 2 };
            switch (direction) {
              case "up":
                return center.y < currentCenter.y;
              case "down":
                return center.y > currentCenter.y;
              case "left":
                return center.x < currentCenter.x;
              case "right":
                return center.x > currentCenter.x;
              default:
                return false;
            }
          });

        if (candidates.length === 0) return currentIndex;

        let bestCandidate = null;
        let minScore = Infinity;

        for (const candidate of candidates) {
          const center = {
            x: candidate.x + candidate.width / 2,
            y: candidate.y + candidate.height / 2,
          };
          const dx = center.x - currentCenter.x;
          const dy = center.y - currentCenter.y;

          let score;
          if (direction === "up" || direction === "down") {
            // Penalize horizontal distance more heavily for vertical navigation
            score = Math.sqrt(dx * dx * 4 + dy * dy);
          } else {
            // Penalize vertical distance more heavily for horizontal navigation
            score = Math.sqrt(dx * dx + dy * dy * 4);
          }

          if (score < minScore) {
            minScore = score;
            bestCandidate = candidate;
          }
        }

        return bestCandidate ? bestCandidate.index : currentIndex;
      }

      function updateSelection() {
        items.forEach((item, index) => {
          item.classList.toggle("selected", index === currentIndex);
        });
      }
      function updateScrollIndicator() {
        document.getElementById("currentIndex").textContent = currentIndex + 1;
        document.getElementById("totalCount").textContent = items.length;
      }
      function scrollToCurrent() {
        if (items[currentIndex]) {
          items[currentIndex].scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }
      function openFullscreen() {
        const currentItem = items[currentIndex];
        if (!currentItem) return;

        // Ensure the current item is loaded for fullscreen
        if (!loadedItems.has(currentIndex)) {
          loadMediaItem(currentIndex);
        }

        updateFullscreenContent();
        document.getElementById("fullscreen").classList.add("active");
        isFullscreen = true;
        updateFileInfo();
      }
      function updateFileInfo() {
        const currentItem = items[currentIndex];
        if (!currentItem) return;

        const itemData = mediaData[currentIndex];
        if (!itemData) return;

        document.getElementById("infoFilename").textContent = itemData.name;
        document.getElementById("infoDimensions").textContent =
          itemData.size.width > 0 && itemData.size.height > 0
            ? `${itemData.size.width} × ${itemData.size.height}`
            : "Unknown";
        document.getElementById("infoType").textContent =
          itemData.type === "video" ? "Video" : "Image";
        
        // Update the file link
        const fileLink = document.getElementById("infoFileLink");
        const fileSrc = currentItem.dataset.src;
        fileLink.href = fileSrc;

        // Show/hide based on toggle state (works both in and out of fullscreen)
        const overlay = document.getElementById("fileInfoOverlay");
        if (showFileInfo) {
          overlay.classList.add("visible");
        } else {
          overlay.classList.remove("visible");
        }
      }

      function updateFullscreenContent() {
        const currentItem = items[currentIndex];
        if (!currentItem) return;

        // Ensure the current item is loaded for fullscreen
        if (!loadedItems.has(currentIndex)) {
          loadMediaItem(currentIndex);
        }

        const fullscreenMedia = document.getElementById("fullscreen-media");
        const type = currentItem.dataset.type;
        const src = currentItem.dataset.src;
        const mimeType = currentItem.dataset.mimeType;
        if (type === "image") {
          fullscreenMedia.innerHTML = `<img src="${src}" alt="Image ${
            currentIndex + 1
          }">`;
        } else {
          const savedTime = videoTimes.get(currentIndex) || 0;
          fullscreenMedia.innerHTML = `<video autoplay loop controls><source src="${src}" type="${mimeType}"></video>`;
          // Wait for video to load, then resume from saved time
          setTimeout(() => {
            const video = fullscreenMedia.querySelector("video");
            if (video) {
              video.addEventListener(
                "loadedmetadata",
                () => {
                  video.currentTime = Math.min(savedTime, video.duration || 0);
                },
                { once: true }
              );
            }
          }, 0);
        }
        updateFileInfo();
      }
      function closeFullscreen() {
        document.getElementById("fullscreen").classList.remove("active");
        isFullscreen = false;
        document.getElementById("fullscreen-media").innerHTML = "";
      }

      // Add click event listener to close fullscreen when clicking backdrop
      document
        .getElementById("fullscreen")
        .addEventListener("click", function (e) {
          if (e.target === this) {
            closeFullscreen();
          }
        });

      // Start automatic scrolling through items
      function startAutoScroll() {
        stopAutoScroll();
        autoScrollTimer = setInterval(() => {
          const speed = Number(autoScrollSpeed.value);
          window.scrollBy({
            top: speed,
            behavior: "smooth",
          });
        }, 50); // Fixed 50ms interval for smooth scrolling
      }
      // Stop automatic scrolling
      function stopAutoScroll() {
        if (autoScrollTimer) {
          clearInterval(autoScrollTimer);
          autoScrollTimer = null;
        }
      }

      // Initialize drop zone when page loads
      document.addEventListener("DOMContentLoaded", function () {
        setupDropZone();
        
        // Setup shortcuts toggle
        const shortcutsToggle = document.getElementById("shortcuts-toggle");
        const shortcutsList = document.getElementById("shortcuts-list");
        const shortcutsContainer = document.querySelector(".shortcuts-container");
        
        shortcutsToggle.addEventListener("click", function (e) {
          e.stopPropagation();
          shortcutsList.classList.toggle("visible");
        });
        
        // Close shortcuts when clicking outside
        document.addEventListener("click", function (e) {
          if (!shortcutsContainer.contains(e.target)) {
            shortcutsList.classList.remove("visible");
          }
        });
      });
    </script>
  </body>
</html>
