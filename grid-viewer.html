<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grid Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #0a0a0a;
        color: #fff;
        overflow-x: hidden;
        user-select: none;
      }

      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        padding: 1rem;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        font-size: 0.9rem;
        opacity: 0.8;
      }

      .controls select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .controls select:focus {
        outline: none;
        border-color: #ff6b6b;
      }

      #zoom-slider {
        vertical-align: middle;
      }

      .drop-zone {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.95);
        z-index: 1500;
        transition: opacity 0.3s ease;
      }

      .drop-zone.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .drop-zone.drag-over {
        background: rgba(255, 107, 107, 0.1);
        border: 2px dashed #ff6b6b;
      }

      .drop-zone h2 {
        font-size: 2rem;
        margin-bottom: 1rem;
        color: #fff;
      }

      .drop-zone p {
        font-size: 1.1rem;
        color: #ccc;
        text-align: center;
        max-width: 500px;
      }

      :root {
        --item-width: 18vw;
        --gap: 8px;
      }
      .masonry-grid {
        margin-top: 80px;
        position: relative;
      }
      .media-item {
        position: absolute;
        border: none;
        border-radius: 0;
        overflow: hidden;
        cursor: pointer;
        background: #1a1a1a;
        transition: box-shadow 0.2s, top 0.3s ease, left 0.3s ease,
          width 0.3s ease;
      }
      .media-item.selected {
        outline: 3px solid #ff6b6b;
        z-index: 10;
      }
      .media-item img,
      .media-item video {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }
      .media-item video {
        background: #000;
      }
      .media-placeholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
      }
      .media-item.loaded .media-placeholder {
        display: none;
        opacity: 0;
        pointer-events: none;
      }
      .media-item.virtualized {
        background: #1a1a1a;
      }
      .media-item.virtualized .media-placeholder {
        background: #1a1a1a;
        color: #333;
      }
      .fullscreen-overlay {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 2000;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .fullscreen-overlay.active {
        opacity: 1;
        pointer-events: all;
      }
      .fullscreen-content {
        max-width: 100vw;
        max-height: 100vh;
        position: relative;
      }
      .fullscreen-content img,
      .fullscreen-content video {
        max-width: 100vw;
        max-height: 100vh;
        object-fit: contain;
      }
      .scroll-indicator {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.9rem;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1 id="title">Grid Viewer</h1>
      <div class="controls">
        <span
          >Zoom:
          <input
            type="range"
            id="zoom-slider"
            min="6"
            max="40"
            value="18"
            step="2"
        /></span>
        <span>← → Arrow WASD/keys to navigate</span>
        <span>Space to maximize</span>
        <span>ESC to close</span>
        <span
          >Auto-scroll speed:
          <input
            type="range"
            id="auto-scroll-speed"
            min="0"
            max="200"
            value="0"
            step="10"
        /></span>
        <span
          >Sort:
          <select id="sort-order">
            <option value="filename-asc">Filename A-Z</option>
            <option value="filename-desc">Filename Z-A</option>
            <option value="mtime">Modified Time</option>
          </select></span
        >
      </div>
    </div>

    <div class="drop-zone" id="dropZone">
      <h2>Drop a PGrid File</h2>
      <p>
        Drag and drop a <code>_pgrid.jpg</code> file generated by grid.ts to
        view the media collection
      </p>
    </div>

    <div class="masonry-grid" id="grid"></div>

    <div class="fullscreen-overlay" id="fullscreen">
      <div class="fullscreen-content" id="fullscreen-media"></div>
    </div>

    <div class="scroll-indicator" id="scrollIndicator">
      <span id="currentIndex">0</span> / <span id="totalCount">0</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js"></script>
    <script>
      let autoScrollTimer = null;
      let currentIndex = 0;
      let items = [];
      let isFullscreen = false;
      let layoutData = [];
      let loadedItems = new Set();
      let observer;
      let loadDebounceTimer = null;
      let visibleItems = new Set();
      let autoScrollSpeed;
      let mediaData = [];
      let baseDirectory = "";
      let currentSortOrder = "filename-asc";

      function setupDropZone() {
        const dropZone = document.getElementById("dropZone");

        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        ["dragenter", "dragover"].forEach((eventName) => {
          dropZone.addEventListener(eventName, highlight, false);
        });

        ["dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
          dropZone.classList.add("drag-over");
        }

        function unhighlight(e) {
          dropZone.classList.remove("drag-over");
        }

        dropZone.addEventListener("drop", handleDrop, false);

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;

          if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith("_pgrid.jpg")) {
              processPgridFile(file);
            } else {
              alert("Please drop a _pgrid.jpg file");
            }
          }
        }
      }

      async function processPgridFile(file) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          // Convert to string to search for our metadata marker
          const fileText = new TextDecoder().decode(uint8Array);

          // Look for our metadata marker
          const startMarker = "<!--PGGRID_METADATA:";
          const endMarker = "-->";

          const startIndex = fileText.lastIndexOf(startMarker);
          if (startIndex === -1) {
            alert("Could not find metadata in the pgrid file");
            return;
          }

          const endIndex = fileText.indexOf(endMarker, startIndex);
          if (endIndex === -1) {
            alert("Invalid metadata format in the pgrid file");
            return;
          }

          // Extract the JSON data between markers
          const jsonStart = startIndex + startMarker.length;
          const jsonText = fileText.substring(jsonStart, endIndex);

          let cacheData;
          try {
            cacheData = JSON.parse(jsonText);
          } catch {
            alert("Invalid JSON metadata in the pgrid file");
            return;
          }

          initializeViewer(cacheData, file.name);
        } catch (e) {
          console.error("Error processing pgrid file:", e);
          alert("Error processing the pgrid file");
        }
      }

      function initializeViewer(cacheData, filename) {
        // Extract directory name from filename (remove _pgrid.jpg)
        const dirName = filename.replace("_pgrid.jpg", "");
        baseDirectory = dirName;

        // Convert cache data to media items
        mediaData = Object.entries(cacheData).map(([name, data]) => {
          const mimeType = getMimeType(name);
          const type = mimeType.startsWith("video/") ? "video" : "image";
          return {
            name,
            size: data.size,
            mimeType,
            type,
            mtime: data.mtime || 0,
          };
        });

        // Apply default sorting (filename A-Z)
        mediaData.sort((a, b) => a.name.localeCompare(b.name));

        // Hide drop zone
        document.getElementById("dropZone").classList.add("hidden");

        // Update title
        document.getElementById("title").textContent = dirName;

        // Generate HTML for media items
        generateMediaItems();

        // Initialize the viewer
        initializeViewerComponents();
      }

      const MIME_TYPES = {
        // Video formats
        mp4: "video/mp4",
        avi: "video/x-msvideo",
        mov: "video/quicktime",
        mkv: "video/x-matroska",
        webm: "video/webm",
        flv: "video/x-flv",
        wmv: "video/x-ms-wmv",
        m4v: "video/x-m4v",
        "3gp": "video/3gpp",
        "3g2": "video/3gpp2",
        ogv: "video/ogg",
        ts: "video/mp2t",
        mts: "video/mp2t",
        m2ts: "video/mp2t",
        vob: "video/mpeg",
        asf: "video/x-ms-asf",
        divx: "video/x-msvideo",
        xvid: "video/x-msvideo",
        f4v: "video/x-f4v",
        mpg: "video/mpeg",
        mpeg: "video/mpeg",
        mpe: "video/mpeg",
        m1v: "video/mpeg",
        m2v: "video/mpeg",
        mpv: "video/mp4",
        mpv2: "video/mp4",
        m4s: "video/mp4",
        m4b: "audio/mp4",
        m4a: "audio/mp4",
        m4p: "audio/mp4",
        m4r: "audio/mp4",
        // Image formats
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        png: "image/png",
        gif: "image/gif",
        bmp: "image/bmp",
        webp: "image/webp",
        svg: "image/svg+xml",
        ico: "image/x-icon",
        tiff: "image/tiff",
        tif: "image/tiff",
        jxl: "image/jxl",
        jp2: "image/jp2",
        jpx: "image/jpx",
        jpm: "image/jpm",
        jpf: "image/jpx",
        heic: "image/heic",
        heif: "image/heif",
        avif: "image/avif",
      };

      function getMimeType(filename) {
        const ext = filename.toLowerCase().split(".").pop();
        return MIME_TYPES[ext] || "application/octet-stream";
      }

      function sortMediaItems() {
        const sortOrder = document.getElementById("sort-order").value;
        currentSortOrder = sortOrder;

        switch (sortOrder) {
          case "filename-asc":
            mediaData.sort((a, b) => a.name.localeCompare(b.name));
            break;
          case "filename-desc":
            mediaData.sort((a, b) => b.name.localeCompare(a.name));
            break;
          case "mtime":
            // Sort by modified time (newest first)
            mediaData.sort((a, b) => {
              const timeA = a.mtime || 0;
              const timeB = b.mtime || 0;
              return timeB - timeA;
            });
            break;
        }

        // Regenerate the grid with new order
        generateMediaItems();

        // Re-initialize items array and recalculate layout
        items = Array.from(document.querySelectorAll(".media-item"));
        calculateLayout();

        // Reset current index to 0 when sorting changes
        currentIndex = 0;
        updateSelection();
        updateScrollIndicator();

        // Re-setup virtualization
        if (observer) {
          observer.disconnect();
        }
        setupVirtualization();

        // Force check for visible items after layout changes
        setTimeout(() => {
          // Clear any existing loaded items since order changed
          loadedItems.clear();

          // Force intersection observer to check all items
          items.forEach((item) => {
            observer.unobserve(item);
            observer.observe(item);
          });

          // Manually trigger loading for items that should be visible
          const visibleItemsArray = Array.from(visibleItems);
          visibleItemsArray.forEach((index) => {
            if (!loadedItems.has(index)) {
              loadMediaItem(index);
            }
          });
        }, 100);

        // Re-attach click and double-click events
        items.forEach((item, index) => {
          item.addEventListener("click", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            scrollToCurrent();
          });

          item.addEventListener("dblclick", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            openFullscreen();
          });
        });
      }

      function generateMediaItems() {
        const grid = document.getElementById("grid");
        const itemsHTML = mediaData
          .map((item, index) => {
            let aspectStyle = "";
            if (item.size.width > 0 && item.size.height > 0) {
              aspectStyle = `style="aspect-ratio: ${item.size.width} / ${item.size.height};"`;
            }
            // Compose src using baseDirectory and item.name
            const src = baseDirectory + "/" + item.name;
            return `<div class="media-item virtualized" data-index="${index}" data-type="${item.type}" data-name="${item.name}" data-src="${src}" data-mime-type="${item.mimeType}" ${aspectStyle}>
                        <div class="media-placeholder">
                            Virtualized
                        </div>
                    </div>`;
          })
          .join("");

        grid.innerHTML = itemsHTML;
      }

      function initializeViewerComponents() {
        items = Array.from(document.querySelectorAll(".media-item"));
        calculateLayout();
        updateSelection();
        updateScrollIndicator();
        setupVirtualization();

        window.addEventListener("resize", calculateLayout);

        // Click to select items
        items.forEach((item, index) => {
          item.addEventListener("click", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            scrollToCurrent();
          });
        });

        // Zoom slider: adjust CSS grid column width
        const zoomSlider = document.getElementById("zoom-slider");
        zoomSlider.addEventListener("input", (e) => {
          const width = e.target.value + "vw";
          document.documentElement.style.setProperty("--item-width", width);
          calculateLayout();
        });

        // Double-click to open fullscreen
        items.forEach((item, index) => {
          item.addEventListener("dblclick", () => {
            currentIndex = index;
            updateSelection();
            updateScrollIndicator();
            openFullscreen();
          });
        });

        // Auto-scroll interval control (0 = off)
        autoScrollSpeed = document.getElementById("auto-scroll-speed");
        autoScrollSpeed.addEventListener("input", () => {
          const speed = Number(autoScrollSpeed.value);
          if (speed > 0) {
            stopAutoScroll();
            startAutoScroll();
          } else {
            stopAutoScroll();
          }
        });

        // Sort order dropdown
        const sortOrderSelect = document.getElementById("sort-order");
        sortOrderSelect.addEventListener("change", () => {
          sortMediaItems();
        });
      }

      function setupVirtualization() {
        // Create intersection observer to load items when they become visible
        observer = new IntersectionObserver(
          (entries) => {
            // Track which items are currently intersecting
            entries.forEach((entry) => {
              const index = parseInt(entry.target.dataset.index);
              if (entry.isIntersecting) {
                visibleItems.add(index);
              } else {
                visibleItems.delete(index);
              }
            });
            // Clear any existing debounce timer
            if (loadDebounceTimer) {
              clearTimeout(loadDebounceTimer);
            }
            // Debounce loading until scrolling stops
            loadDebounceTimer = setTimeout(() => {
              visibleItems.forEach((index) => {
                if (!loadedItems.has(index)) {
                  loadMediaItem(index);
                }
              });
            }, 150); // 150ms debounce delay
          },
          {
            rootMargin: "300px", // Start loading 300px before item becomes visible
          }
        );
        // Observe all items
        items.forEach((item) => {
          observer.observe(item);
        });
      }

      function loadMediaItem(index) {
        if (loadedItems.has(index)) return;

        const item = items[index];
        const type = item.dataset.type;
        const src = item.dataset.src;

        // Update placeholder text to show loading state
        const placeholder = item.querySelector(".media-placeholder");
        placeholder.textContent = "Loading...";

        loadedItems.add(index);
        item.classList.remove("virtualized");

        if (type === "image") {
          const img = document.createElement("img");
          img.src = src;
          img.onload = () => {
            item.classList.add("loaded");
          };
          img.onerror = () => {
            item.querySelector(".media-placeholder").textContent =
              "Failed to load";
            item.classList.add("loaded");
          };
          item.appendChild(img);
        } else if (type === "video") {
          const video = document.createElement("video");
          video.src = src;
          video.muted = true;
          video.loop = true;
          video.playsInline = true;
          video.autoplay = true;
          video.onloadeddata = () => {
            item.classList.add("loaded");
          };
          video.onerror = () => {
            item.querySelector(".media-placeholder").textContent =
              "Failed to load";
            item.classList.add("loaded");
          };
          item.appendChild(video);
        }
      }

      function calculateLayout() {
        const grid = document.getElementById("grid");
        const gap = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue("--gap")
        );
        const itemWidthVW = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--item-width"
          )
        );
        const itemWidthPx = (itemWidthVW / 100) * window.innerWidth;

        const containerWidth = grid.clientWidth;
        const numColumns = Math.max(
          1,
          Math.round(containerWidth / itemWidthPx)
        );
        const colWidth = (containerWidth - (numColumns + 1) * gap) / numColumns;

        const colHeights = Array(numColumns).fill(gap);
        layoutData = [];

        mediaData.forEach((media, index) => {
          const item = items[index];
          const aspectRatio = media.size.width / media.size.height;
          const itemHeight = colWidth / aspectRatio;

          let shortestColIndex = 0;
          for (let i = 1; i < numColumns; i++) {
            if (colHeights[i] < colHeights[shortestColIndex]) {
              shortestColIndex = i;
            }
          }

          const top = colHeights[shortestColIndex];
          const left = gap + shortestColIndex * (colWidth + gap);

          item.style.left = left + "px";
          item.style.top = top + "px";
          item.style.width = colWidth + "px";
          item.style.height = itemHeight + "px";

          layoutData[index] = {
            x: left,
            y: top,
            width: colWidth,
            height: itemHeight,
            col: shortestColIndex,
          };
          colHeights[shortestColIndex] += itemHeight + gap;
        });

        const totalHeight = Math.max(...colHeights);
        grid.style.height = totalHeight + "px";
      }

      // Keyboard navigation
      document.addEventListener("keydown", function (e) {
        if (isFullscreen) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          if (e.key === " ") {
            e.preventDefault();
            closeFullscreen();
            return;
          }
          // Allow navigation in fullscreen mode
          let nextIndex = currentIndex;
          switch (e.key) {
            case "ArrowLeft":
            case "a":
            case "A":
              e.preventDefault();
              nextIndex = findNearest("left");
              break;
            case "ArrowRight":
            case "d":
            case "D":
              e.preventDefault();
              nextIndex = findNearest("right");
              break;
            case "ArrowUp":
            case "w":
            case "W":
              e.preventDefault();
              nextIndex = findNearest("up");
              break;
            case "ArrowDown":
            case "s":
            case "S":
              e.preventDefault();
              nextIndex = findNearest("down");
              break;
            case "Home":
              e.preventDefault();
              nextIndex = 0;
              break;
            case "End":
              e.preventDefault();
              nextIndex = items.length - 1;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              e.preventDefault();
              const percentage = parseInt(e.key) * 10;
              const scrollHeight =
                document.documentElement.scrollHeight - window.innerHeight;
              const targetScroll = (scrollHeight * percentage) / 100;
              window.scrollTo({
                top: targetScroll,
                behavior: "smooth",
              });
              return;
            default:
              return;
          }
          currentIndex = nextIndex;
          updateSelection();
          updateScrollIndicator();
          updateFullscreenContent();
          return;
        }

        let nextIndex = currentIndex;
        switch (e.key) {
          case "ArrowLeft":
          case "a":
          case "A":
            e.preventDefault();
            nextIndex = findNearest("left");
            break;
          case "ArrowRight":
          case "d":
          case "D":
            e.preventDefault();
            nextIndex = findNearest("right");
            break;
          case "ArrowUp":
          case "w":
          case "W":
            e.preventDefault();
            nextIndex = findNearest("up");
            break;
          case "ArrowDown":
          case "s":
          case "S":
            e.preventDefault();
            nextIndex = findNearest("down");
            break;
          case " ":
            e.preventDefault();
            openFullscreen();
            return;
          case "Home":
            e.preventDefault();
            nextIndex = 0;
            break;
          case "End":
            e.preventDefault();
            nextIndex = items.length - 1;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            e.preventDefault();
            const percentage = parseInt(e.key) * 10;
            const scrollHeight =
              document.documentElement.scrollHeight - window.innerHeight;
            const targetScroll = (scrollHeight * percentage) / 100;
            window.scrollTo({
              top: targetScroll,
              behavior: "smooth",
            });
            return;
          default:
            return;
        }
        currentIndex = nextIndex;
        updateSelection();
        updateScrollIndicator();
        scrollToCurrent();
      });

      function findNearest(direction) {
        if (layoutData.length === 0) return currentIndex;

        const current = { ...layoutData[currentIndex], index: currentIndex };
        const currentCenter = {
          x: current.x + current.width / 2,
          y: current.y + current.height / 2,
        };

        const candidates = layoutData
          .map((p, i) => ({ ...p, index: i }))
          .filter((p) => {
            const center = { x: p.x + p.width / 2, y: p.y + p.height / 2 };
            switch (direction) {
              case "up":
                return center.y < currentCenter.y;
              case "down":
                return center.y > currentCenter.y;
              case "left":
                return center.x < currentCenter.x;
              case "right":
                return center.x > currentCenter.x;
              default:
                return false;
            }
          });

        if (candidates.length === 0) return currentIndex;

        let bestCandidate = null;
        let minScore = Infinity;

        for (const candidate of candidates) {
          const center = {
            x: candidate.x + candidate.width / 2,
            y: candidate.y + candidate.height / 2,
          };
          const dx = center.x - currentCenter.x;
          const dy = center.y - currentCenter.y;

          let score;
          if (direction === "up" || direction === "down") {
            // Penalize horizontal distance more heavily for vertical navigation
            score = Math.sqrt(dx * dx * 4 + dy * dy);
          } else {
            // Penalize vertical distance more heavily for horizontal navigation
            score = Math.sqrt(dx * dx + dy * dy * 4);
          }

          if (score < minScore) {
            minScore = score;
            bestCandidate = candidate;
          }
        }

        return bestCandidate ? bestCandidate.index : currentIndex;
      }

      function updateSelection() {
        items.forEach((item, index) => {
          item.classList.toggle("selected", index === currentIndex);
        });
      }
      function updateScrollIndicator() {
        document.getElementById("currentIndex").textContent = currentIndex + 1;
        document.getElementById("totalCount").textContent = items.length;
      }
      function scrollToCurrent() {
        if (items[currentIndex]) {
          items[currentIndex].scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        }
      }
      function openFullscreen() {
        const currentItem = items[currentIndex];
        if (!currentItem) return;

        // Ensure the current item is loaded for fullscreen
        if (!loadedItems.has(currentIndex)) {
          loadMediaItem(currentIndex);
        }

        updateFullscreenContent();
        document.getElementById("fullscreen").classList.add("active");
        isFullscreen = true;
      }
      function updateFullscreenContent() {
        const currentItem = items[currentIndex];
        if (!currentItem) return;

        // Ensure the current item is loaded for fullscreen
        if (!loadedItems.has(currentIndex)) {
          loadMediaItem(currentIndex);
        }

        const fullscreenMedia = document.getElementById("fullscreen-media");
        const type = currentItem.dataset.type;
        const src = currentItem.dataset.src;
        const mimeType = currentItem.dataset.mimeType;
        if (type === "image") {
          fullscreenMedia.innerHTML = `<img src="${src}" alt="Image ${
            currentIndex + 1
          }">`;
        } else {
          fullscreenMedia.innerHTML = `<video autoplay muted loop controls><source src="${src}" type="${mimeType}"></video>`;
        }
      }
      function closeFullscreen() {
        document.getElementById("fullscreen").classList.remove("active");
        isFullscreen = false;
        document.getElementById("fullscreen-media").innerHTML = "";
      }

      // Add click event listener to close fullscreen when clicking backdrop
      document
        .getElementById("fullscreen")
        .addEventListener("click", function (e) {
          if (e.target === this) {
            closeFullscreen();
          }
        });

      // Start automatic scrolling through items
      function startAutoScroll() {
        stopAutoScroll();
        autoScrollTimer = setInterval(() => {
          const speed = Number(autoScrollSpeed.value);
          window.scrollBy({
            top: speed,
            behavior: "smooth",
          });
        }, 50); // Fixed 50ms interval for smooth scrolling
      }
      // Stop automatic scrolling
      function stopAutoScroll() {
        if (autoScrollTimer) clearInterval(autoScrollTimer);
      }

      // Initialize drop zone when page loads
      document.addEventListener("DOMContentLoaded", function () {
        setupDropZone();
      });
    </script>
  </body>
</html>
